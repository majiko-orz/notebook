![](img/JVM_6.png)

![](img/JVM_55.png)

### 1.  jvm生命周期

+ **虚拟机启动**

  Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的

+ **虚拟机执行**

  一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序

  程序开始执行时他才运行，程序结束时他就停止

  执行一个所谓的Java程序的时候，真正在执行的是一个叫做Java虚拟机的进程

+ **虚拟机退出**

  有如下几种情况

  1. 程序正常执行结束

  2. 程序在执行过程中遇到异常或错误而异常终止

  3. 由于操作系统出现错误而导致Java虚拟机进程终止

  4. 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作
  5. 除此之外，JNI（Java native interface）规范描述了用JNI invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况

### 2. 类加载器子系统

![](img/JVM_1.png)

+ 类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件头有特定的文件标识
+ ClassLoader只负责class文件的加载，至于他是否可以运行，则由Execution Engine决定
+ 加载的类信息存放于一块称为方法区的内存空间，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）

#### **类加载器ClassLoader角色**

![](img/JVM_2.png)

#### **加载（loading）**

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时的数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

#### **链接（linking）**

1. **验证（Verify）**
   + 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
   + 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证
2. **准备（Prepare）**
   + 为**类变量**分配内存并且设置该类变量的默认初始值，即零值。
   + **这里不包含用final修饰的static**，因为final在编译的时候就会分配了，准备阶段会显式初始化
   + **这里不会为实例变量分配初始化**，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中
3. **解析（Resolve）**
   + 将常量池内的符号引用转换为直接引用的过程
   + 事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行
   + 符号引用是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
   + 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等

#### **初始化（initialization）**

+ **初始化阶段就是执行类构造方法<clinit>()的过程。**
+ 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
+ 构造器方法中指令按语句在源文件中出现的顺序执行
+ **<clinit>()不同于类的构造器。**（关联：构造器是虚拟机视角下的<init>()）
+ 若该类具有父类，jvm会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕
+ 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁



#### **类加载器的分类**

+ jvm支持两种类型的类加载器，分别是**引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）**
+ 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器**
+ 无论类加载器如何划分，在程序中我们最常见的类加载器始终只有三个：

![](img/JVM_3.png)

对于用户自定义类来说，默认使用系统类加载器（System ClassLoader）进行加载

Java的核心类库都是使用引导类加载器（Bootstrap ClassLoader）进行加载的

**启动类加载器（引导类加载器，Bootstrap ClassLoader）**

+ 这个类加载使用C/C++语言实现的，嵌套在jvm内部
+ 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供自身需要的类
+ 并不继承自java.lang.ClassLoader,没有父类加载器
+ 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
+ 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

**扩展类加载器（Extension ClassLoader）**

+ 虚拟机自带的加载器
+ Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
+ 派生于ClassLoader类
+ 父类加载器为启动类加载器
+ 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载。

**应用程序类加载器（系统类加载器，AppClassLoader）**

+ 虚拟机自带的加载器

+ Java语言编写，由sun.misc.Launcher$AppClassLoader实现
+ 派生于ClassLoader类
+ 父类加载器为扩展类加载器
+ 他负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
+ 该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载
+ 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器

**用户自定义类加载器**

为什么要自定义类加载器

+ 隔离加载类
+ 修改类加载方式
+ 扩展加载源
+ 防止源码泄漏

**用户自定义类加载器实现步骤**

1. 继承java.lang.ClassLoader类
2. jdk1.2之前，总会继承ClassLoader并重写loadClass()方法，但在jdk1.2之后建议把自定义的类加载器逻辑写在findClass()方法中
3. 如果没有太过复杂的需求，可以直接继承URLClassLoader类

#### 获取ClassLoader的途径

1. 获取当前类的ClassLoader

   clazz.getClassLoader()

2. 获取当前线程上下文的ClassLoader

   Thread.currentThread().getContextClassLoader()

3. 获取系统的ClassLoader

   ClassLoader.getSystemClassLoader()

4. 获取调用者的ClassLoader

   DriverManager.getCallerClassLoader()

#### 双亲委派机制

Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将他的class文件加载到内存中生成Java对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，他是一种任务委派模式

**工作原理**

+ 如果一个类加载器收到了加载类的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行
+ 如果父类的加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器
+ 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制

![](img/JVM_4.png)

加载外部包

![](img/JVM_5.png)

**优势：**

+ 避免类的重复加载
+ 保护程序安全，防止核心API被随意篡改

#### 沙箱安全机制

自定义String类，但是在加载自定义String类的时候会先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对核心java源代码的保护，这就是沙箱安全机制

#### 其他

在JVM中表示两个class对象是否为同一个类存在两个必要条件：

+ 类的完整类名必须一致，包括包名
+ 加载这个类的ClassLoader(指ClassLoader实例对象)必须相同

换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不相等的

JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的 

**类的主动使用和被动使用**

Java程序对类的使用方式分为：主动使用和被动使用

主动使用，又分为七种情况

+ 创建类的实例

+ 访问某个类或接口的静态变量，或者对该静态变量赋值

+ 调用类的静态方法

+ 反射

+ 初始化一个类的子类

+ Java虚拟机启动时被标明为启动类的类

+ JDK7开始提供的动态语言支持：

  java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化

### 3. 运行时数据区概述及线程

![](img/JVM_7.png)

![](img/JVM_8.png)

java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区会随着线程开始和结束而创建和销毁。

灰色的为单独线程私有的，红色为多个线程共享的。即

+ 每个线程：独立包括程序计数器、栈、本地栈。
+ 线程间共享：堆、堆外内存（用代或元空间、代码缓存）

**线程**

+ 线程是一个程序里的运行单元，JVM允许一个应用有多个线程并行执行
+ 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射，当一个Java线程准备好执行后，此时一个操作系统的本地线程也同时创建，Java线程执行终止后，本地线程也会回收
+ 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，他会调用Java线程中的run()方法

**JVM系统线程**

+ 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现，这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销
+ 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行
+ GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
+ 编译线程：这种线程在运行时会将字节码编译成到本地代码
+ 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理

### 4. 程序计数器（PC寄存器）

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

![](img/JVM_9.png)

+ 它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域。

+ 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
+ 任何时间一个线程都只有一个方法在运行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）
+ 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
+ 字节码解释器工作时就是通过改变这个计数器的值来获取下一条需要执行的字节码指令
+ 他是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

**两个常见问题**

**使用pc寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪里开始继续执行，JVM字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令

**PC寄存器为什么会被设定为线程私有**

为了能够准确的记录各个线程正在执行的当前字节码指令的地址，最好的办法就是为每一个线程都分配一个PC寄存器

### 5. 虚拟机栈

#### 概述

优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令

**栈是运行时的单位，而堆是存储的单位**

**Java虚拟机栈**（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个小的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的，**生命周期**和线程一致，**作用**主管Java程序的运行，他保存方法的局部变量、部分结果、并参与方法的调用和返回。

栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器，JVM直接对Java栈的操作只有两个：每个方法执行，伴随着进栈，执行结束后的出栈。对于栈来说不存在垃圾回收问题

**栈中可能出现的异常**

Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的

+ 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**StackOverflowError**异常
+ 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应下虚拟机栈，那Java虚拟机将会抛出一个**OutOfMemoryError**异常

**设置栈内存大小**

可以使用参数-Xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

#### 栈的存储单元

**栈中存储什么**

+ 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在

+ 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）
+ 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

**栈运行原理**

+ 不同线程中所包含的栈帧是不允许存在相互引用的，即不可逆在一个栈帧之中引用另外一个线程的栈帧
+ 如果当前方法调用了其他方法，方法返回之际，当前栈帧会返回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
+ Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常。不管哪种方式，都会导致栈帧被弹出

**栈帧的内部结构**

+ 局部变量表（Local Variables）
+ 操作数栈（Operand Stack）（或表达式栈）
+ 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
+ 方法返回地址（Rerurn Address）（或方法正常退出或者异常退出的定义）
+ 一些附加信息

#### 局部变量表

+ 局部变量表也被称之为局部变量数组或本地变量表

+ 定义为一个**数字数组**，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用、以及returnAddress类型

  局部变量表，最基本的存储单元是Slot(变量槽)，32位以内的类型只占用一个slot(包括returnAddress类型)，64位的类型(long和double)占用两个slot

+ 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
+ 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量的大小的

+ 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多
+ 局部变量表中的变量只在当前方法调用中有效。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁

**slot(变量槽)**

+ JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
+ 当一个实例方法被调用的时候，他的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
+ 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。
+ 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余参数按照参数表顺序继续排列

局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收

#### 操作数栈

+ 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可称之为表达式栈
+ 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）
+ 操作数栈，主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间
+ 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的
+ 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值
+ 栈中任何一个元素都是可以任意的Java数据类型，32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度
+ 操作数栈并非采用访问索引的方式进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作来完成一次数据访问
+ 如果被调用的方法带有返回值，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令
+ 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证
+ 另外，我们说Java虚拟机的解释引擎是基于栈指的就是操作数栈

**栈顶缓存技术**

栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率

#### 动态链接

![](img/JVM_10.png)

+ 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：invokedynamic指令
+ 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

**方法调用**

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。

+ 静态链接

  当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接

+ 动态链接

  如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将此调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

+ 非虚方法

  如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法

  静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法，其他方法称为虚方法



虚拟机中提供了以下几条方法调用指令

+ 普通调用指令
  1. invokestatic：调用静态方法，解析阶段确定唯一方法版本
  2. invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本
  3. invokevirtual：调用所有虚方法
  4. invokeinterface：调用接口方法
+ 动态调用指令
  5. invokedynamic：动态解析出需要调用的方法，然后执行

前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本，其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法

**Java中方法重写的本质**

1. 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
2. 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常
3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的操作和验证过程。
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

IllegalAccessError介绍：

程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常，这个错误如果发生在运行时，就说明一个类发生了不兼容的改变

**虚方法表**

+ 在面向对象的编程中，会很频繁的使用到动态分配，如果在每次动态分配的过程中都要重新在类的方法元数据中搜素合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（非虚方法不在表中）来实现。使用索引表来代替查找
+ 每个类都有一个虚方法表，表中存放着各个方法的实际入口
+ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完成

#### 方法返回地址

+ 存放调用该方法的pc寄存器的值
+ 一个方法的结束，有两种方式：正常执行完成；出现未处理的异常，非正常退出
+ 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息

本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器的值等，让调用者方法继续执行下去。

正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。

### 6. 本地方法栈

+ Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
+ 本地方法栈也是线程私有的
+ 允许被实现成固定或者是可动态扩展的内存大小
  + 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常
  + 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常
+ 本地方法是使用C语言实现的
+ 他的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库
+ 当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界。他和虚拟机拥有同样的权限
  + 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  + 他甚至可以直接使用本地处理器中的寄存器
  + 直接从本地内存的堆中分配任意数量的内存
+ 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等
+ 在Hotspot JVM中，直接讲本地方法栈和虚拟机栈合二为一

### 7. 堆

#### 堆的核心概述

+ 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域
+ Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间，堆内存大小是可以调节的
+ 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上他应该被视为连续的
+ 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（ThreadLocal Allocation Buffer,TLAB）
+ 《Java虚拟机规范》中对Java堆的描述是：几乎所有的对象实例以及数组都应当在运行时分配在堆上
+ 数组和对象永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
+ 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除
+ 堆，是GC执行垃圾回收的重点区域 

**内存细分**

现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：

![](img/JVM_11.png)

#### 设置堆内存大小与OOM

+ Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项"-Xmx"和"-Xms"来设置
  + "-Xms"用于表示堆区（年轻代+老年代）的起始内存，等价于-XX:InitialHeapSize
  + "-Xmx"用于表示堆区（年轻代+老年代）的最大内存，等价于-XX:MaxHeapSize
+ 一旦堆区中的内存大小超过"-Xmx"所指定的最大内存时，将会抛出OutOfMemoryError异常
+ **通常会将-Xms和-Xmx两个参数配置相同的值**，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能

+ 默认堆空间大小

  初始内存大小：物理电脑内存大小/64

  最大内存大小：物理电脑内存大小/4

+ 查看设置的参数：

  方式一：jps + jstat -gc 进程id

  方式二：-XX:+PrintGCDetails

#### 年轻代与老年代

+ 存储在JVM中的Java对象可以被划分为两类：
  + 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  + 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致
+ Java堆区进一步细分的话，可以划分为年轻代和老年代
+ 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫from区、to区）

![](img/JVM_12.png)

+ 配置新生代与老年代在堆结构的占比
  + 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
  + 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
+ 在Hotspot中，Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1
+ -XX:-UseAdaptiveSizePolicy：关闭自适应的内存分配策略
+ 开发人员可以通过选项-XX:SurvivorRatio调整这个空间比例。比如XX:SurvivorRatio=8
+ 几乎所有的Java对象都是在Eden区被new出来的
+ 绝大部分的Java对象的销毁都在新生代进行了
+ 可以使用选项"-Xmn"设置新生代最大内存大小，一般不设置

#### 对象分配过程

为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片

1. new的对象先放伊甸园区。此区有大小限制
2. 当伊甸园区的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
3. 然后将伊甸园区中剩余的对象移动到幸存者0区
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区
6. 啥时候能去养老区呢？可以设置次数。默认是15次，-XX:MaxTenuringThreshold=<N>

总结：

+ 针对幸存者s0,s1区的总结：复制之后有交换，谁空谁是to
+ 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集

![](img/JVM_13.png)

#### Minor GC、Major GC、Full GC

JVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代、方法区）一起回收的，大部分时候回收的都是指新生代

针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）

+ 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：

  + 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集

  + 老年代收集（Major GC / Old GC）：只是老年代的垃圾收集

    目前，只有CMS GC会有单独收集老年代的行为

    注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代还是整堆回收

  + 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。

    目前，只有G1 GC会有这种行为

+ 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集

**年轻代GC（Minor GC）触发机制**

+ 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Surviror满不会引发GC。（每次Minor GC会清理年轻代的内存）
+ 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC 非常频繁，一般回收速度也比较快。
+ Minor GC会引发STW(Stop the Work)，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行

**老年代GC（Major GC / Full GC）触发机制**

+ 指发生在老年代的GC，对象从老年代消失时，我们说Major GC或Full GC发生了
+ 出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)，也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC
+ Major GC的速度一般会比Minor GC慢10倍以上，STW时间更长
+ 如果Major GC后，内存还不足，就报OOM了

**Full GC触发机制**

+ 调用System.gc()时，系统建议执行Full GC，但是不必然执行
+ 老年代空间不足
+ 方法区空间不足
+ 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
+ 由Eden区、survivor space0(from space)区向survivor space1(to space)区复制时，对象大小大于to space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

说明，full gc是开发中或调优中尽量要避免的。这样暂时时间会短一些

#### 堆空间分代思想

分代的唯一理由就是优化GC的性能

#### 内存分配策略

对象在Survivor区中每熬过一次MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认是15岁，每个JVM,每个GC有所不同），就会晋身到老年代

对象晋身到老年代的年龄阈值，可以通过-XX:MaxTenuringThreshold设置

针对不同年龄段的对象分配原则如下所示：

+ 优先分配到Eden

+ 大对象直接分配到老年代

  尽量避免程序中出现过多的大对象

+ 长期存活的对象分配到老年代

+ 动态对象年龄判断

  如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

+ 空间分配担保

  -XX:HandlePromotionFailure

#### 为对象分配内存：TLAB

TLAB（Thread Local Allocation Buffer），本地分配缓存区

+ 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
+ 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
+ 为避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度

**什么是TLAB**

+ 从内存模型而不是垃圾回收的角度，对Eden区域进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内
+ 多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略
+ OpenJDK衍生出来的JVM都提供了TLAB的设计
+ 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实式将TLAB作为内存分配的首选
+ 在程序中，开发人员可以通过选项"-XX:UseTLAB"设置是否开启TLAB空间
+ 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项"-XX:TALBWasteTargetPercent"设置TLAB空间所占用Eden空间的百分比大小
+ 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存

**对象分配过程**

![](img/JVM_14.png)

#### 堆空间参数设置

https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC

+ -XX:+PrintFlagsInitial：查看所有的参数的默认初始值

+ -XX:+PrintFlagsFinal：查看所有参数的最终值（可能存在修改，不再是初始值）

+ -Xms：初始堆空间内存（默认为物理内存的1/64）

+ -Xmx：最大堆空间内存（默认为物理内存的1/4）

+ -Xmn：设置新生代的大小（初始值及最大值）

+ -XX:NewRatio：设置新生代与老年代在堆结构的占比

+ -XX:SurvivorRatio：设置新生代中Eden和s0/s1空间的比例

+ -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄

+ -XX:+PrintGCDetails：输出详细的GC处理日志

  打印GC简要信息：-XX:+PrintGC，-verbose:gc

+ -XX:HandlePromotionFailure：是否设置空间分配担保



在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间

+ 如果大于，则此次Minor GC是安全的
+ 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败
  + 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小
    + 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的
    + 如果小于，则改为进行一次Full GC
  + 如果HandlePromotionFailure=false，则改为进行一次Full GC

**在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略**，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC

#### 堆是分配对象的唯一选择吗

在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：随着JIT编译器的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替代优化技术**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变的不那么绝对了

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是**如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术

此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH(GC invisible heap)技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的

**逃逸分析概述**

+ 如何将堆上的对象分配到栈，需要使用逃逸分析手段

+ 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法
+ 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上
+ 逃逸分析的基本行为就是分析对象动态作用域
  + 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
  + 当一个对象在方法中被定义后，他被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中

**如何快速的判断是否发生了逃逸，就看new的对象是否有可能在方法外被调用**

**参数设置**

+ JDK 6u23版本之后，Hotspot中默认就已经开启了逃逸分析。
+ 如果使用的是较早的版本，开发人员则可以通过
  + -XX:+DoEscapeAnalysis显式开启逃逸分析
  + -XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果

**逃逸分析：代码优化**

+ **栈上分配**。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配

  JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被收回，局部变量对象也被回收，这样就无需进行垃圾回收了

+ **同步省略**。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步

  线程同步的代价是相当高的，同步的后果是降低并发性和性能

  在动态编译同步块的同时，**JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程**。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能，这个取消同步的过程就叫同步省略，也叫**锁消除**

+ **分离对象或标量替代**。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中

  **标量（Scalar）**是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做**聚合量（Aggregate）**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

  在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是**标量替换**

  标量替换参数设置：-XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上

Hotspot VM并未应用栈上分配，使用了标量替换

**开发中能使用局部变量的，就不要使用在方法外定义**

### 8. 方法区

#### 栈、堆、方法区的交互关系

![](img/JVM_15.png)

#### 方法区的理解

《Java虚拟机规范》中明确说明："尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会去选择继续垃圾收集或者进行压缩"，但对于HotspotJVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。

方法区看作是一块独立于Java堆的内存空间

+ 方法区（Method Area）和堆一样，是各个线程共享的内存区域
+ 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的
+ 方法区的大小跟堆空间一样，可以选择固定大小或者可扩展
+ 方法区的大小决定了系统可以保持多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError：PermGen space或者java.lang.OutOfMemoryError：Metaspace
+ 关闭JVM就会释放这个区域的内存

**Hotspot中方法区的演进**

+ **在jdk7以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代**。
+ **本质上，方法区和永久代并不等价。仅是对hotspot而言的。**《Java虚拟机规范》对如何实现方法区，不做统一要求。例如BEA JRockit / IBM J9中不存在永久代的概念。现在看来，当年使用永久代，不是好的idea。导致Java程序更容易OOM
+ 而到了JDK8，终于完全放弃了永久代的概念，改用JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替
+ 元空间本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：**元空间不在虚拟机设置的内存中，而是使用本地内存**
+ 永久代、元空间二者并不是名字变了，内部结构也调整了
+ 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM

#### 设置方法区大小与OOM

+ 方法区的大小不必是固定的，JVM可以根据应用的需要动态调整
+ jdk7及以前
  + 通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M
  + -XX:MaxPermSize来设置永久代最大可分配空间。32位机器默认是64M，64位机器默认是82M
  + 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space
+ jdk8及以后
  + 元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数
  + 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制
  + 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace
  + -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21M。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不在存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值
  + 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁的GC，建议将-XX:MetaspaceSize设置为一个相对较高的值

**如何解决OOM**

1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Lead）还是内存溢出(Memory Overflow)
2. 如果是内存泄漏，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确的定位出泄露代码的位置
3. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗

#### 方法区的内部结构

《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等

![](img/JVM_16.png)

+ 类型信息。对每个加载的类型（类class、接口interface、枚举enum、注解annotaion），JVM必须在方法区中存储以下类型信息：
  + 这个类型的完整有效名称（全名=包名.类名）
  + 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
  + 这个类型的修饰符（public，abstract，final的某个子类）
  + 这个类型的直接接口的一个有序列表
+ 域信息
  + JVM必须在方法区中保持类型的所有域的相关信息以及域的声明顺序
  + 域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）
+ 方法信息。JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：
  + 方法名称
  + 方法的返回类型（或void）
  + 方法参数的数量和类型（按顺序）
  + 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
  + 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
  + 异常表（abstract和native方法除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

+ non-final的类变量

  + 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
  + 类变量被类的所有实例共享，即使没有类实例你也可以访问它

+ 全局常量：static final。被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被赋值了

  

**运行时常量池vs常量池**

方法区内部包含了运行时常量池，字节码文件内部包含了常量池，要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区，要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池

![](img/JVM_17.png)

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用

**为什么需要常量池**

一个Java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池

**常量池中有什么**

几种在常量池内存储的数据类型包括：

+ 数量值
+ 字符串值
+ 类引用
+ 字段引用
+ 方法引用

常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型

**运行时常量池**

+ 运行时常量池（Runtime Constant Pool）是方法区的一部分
+ 常量池表（Constant Pool Table）是Class文件的一部分，**用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中**
+ 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池
+ JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过**索引访问**的
+ 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址，运行时常量池相对于Class文件常量池的另一重要特征是：**具备动态性**。String.intern()
+ 运行时常量池类似传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表更加丰富一点
+ 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常

#### 方法区的演进细节

+ 首先明确：只有Hotspot才有永久代，BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一

+ Hotspot中方法区的变化：

  | jdk1.6及以前 | 有永久代（permanent generation），静态变量存放在永久代上     |
  | ------------ | ------------------------------------------------------------ |
  | jdk1.7       | 有永久代，但已经逐步去永久代，字符串常量池、静态变量移除，保存在堆中 |
  | jdk1.8及以后 | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆 |

  ![](img/JVM_18.png)

  ![](img/JVM_19.png)

  ![](img/JVM_20.png)



**永久代为什么要被元空间替代**

+ 随着Java8的到来，Hotspot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）

+ 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间

+ 这项改动是有必要的，原因有：

  + **为永久代设置空间大小是很难确定的**

    在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误，而元空间和永久代最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制

  + **对永久代进行调优是很困难的**

**StringTable为什么要调整**

jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收

#### 方法区的垃圾回收

**方法区的垃圾收集主要回收两部分内容：常量池废弃的常量和不再使用的类型**

+ 方法区内常量池主要存放两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
+ Hotspot虚拟机对常量池的回收策略是很明确的，**只要常量池中的常量没有被任何地方引用，就可以被回收**
+ 回收废弃常量与回收Java堆中的对象非常类似
+ 判断一个常量是否废弃还是相对简单，而要判定一个类型是否属于不再被使用的类，条件就比较苛刻了。需要同时满足下面三个条件
  + 该类的所有实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例
  + 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI、JSP的重加载等，否则通常是很难达成的
  + 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
+ Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而不是和对象一样，没有引用了必然会回收。关于是否要对类型进行回收，Hotspot虚拟机提供了-Xnoclassgc参数进行控制，还可以用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息
+ 在大量使用反射、动态代理、CGLIB等字节码框架，动态生成JSP以及OSGI这类频繁自定义类加载器的场景中，通常需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力

### 9. 本地方法接口

**本地方法**

简单地讲，一个Native Method就是一个Java调用非Java代码的接口，一个Native Method是这样的一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编程语言都有这一机制，比如在C++中，你可以用extern "C"告知C++编译器去调用一个C的函数

在定义一个native method时，并不提供实现体，因为其实现体是由非Java语言在外面实现的

本地接口的作用时融合不同的编程语言为Java所用，他的初衷是融合C/C++程序

**为什么要使用Native Method**

+ 与Java环境外交互

  有时Java应用需要与Java外面的环境交互，这就是本地方法存在的主要原因。

+ 与操作系统交互

  通过本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的

+ Sun's Java

  sun的解释器是用C实现的，这使得他能像一些普通的C一样与外部交互

### 10. 对象的实例化，内存布局与访问定位

#### 对象的实例化

![](img/JVM_21.png)

![](img/JVM_22.png)

1. 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在），如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象
2. 首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小
   1. 内存规整，那么虚拟机采用的是指针碰撞法（Bump the Point）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞。
   2. 内存不规整，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为空闲列表（Free List）
   3. 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否拥有压缩整理功能决定
3. -
4. -
5. 将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中，这个过程的具体设置方式取决于JVM实现
6. 在Java程序的视角来看，初始化才正式开始，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有invokespecial指令决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来

#### 对象的内存布局

![](img/JVM_23.png)

![](img/JVM_24.png)

#### 对象访问定位

**JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？**

通过栈上reference访问

![](img/JVM_25.png)

对象访问方式主要有两种

+ 句柄访问

  ![](img/JVM_26.png)

  

  好处：reference中存储句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改

  

+ 直接指针（Hotspot采用）

  ![](img/JVM_27.png)

  好处：节省空间，速度快

### 11. 直接内存

+ 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域
+ 直接内存是在Java堆外的、直接向系统申请的内存区间
+ 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存
+ 通常，访问直接内存的速度会优于Java堆。即读写性能提高。因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。Java的NIO库允许Java程序使用直接内存，用于数据缓冲区
+ 也可能导致OutOfMemoryError异常
+ 由于直接内存在Java堆外，因此大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存
+ 缺点：分配回收成本较高、不受JVM内存回收管理
+ 直接内存大小可以通过MaxDirectMemorySize设置
+ 如果不指定，默认与堆的最大值-Xmx参数一致

### 12. 执行引擎

![](img/JVM_28.png)

#### 执行引擎概述

+ 执行引擎是Java虚拟机核心的组成部分之一
+ 虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式
+ JVM的主要任务是负责**装载字节码到其内部**，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。那么，如果想要让 一个Java程序运行起来，执行引擎（Execution Engine）的任务就是**将字节码指令解释/编译为对应平台上的本地机器指令**才可以。简单来说，JVM的执行引擎充当了将高级语言翻译为本地机器语言的译者

**执行引擎的工作过程**

![](img/JVM_29.png)

1. 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器
2. 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址
3. 当然方法在执行的过程中，执行引擎可能会通过存储在局部变量中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息

#### Java代码编译和执行的过程

![](img/JVM_30.png)

大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤

Java代码编译是由Java源码编译器来完成，流程图如下：

![](img/JVM_31.png)

Java字节码的执行是由JVM执行引擎来完成，流程图如下：

![](img/JVM_32.png)

**什么是解释器（Interpreter），什么是JIT编译器**

+ 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译成对应平台的本地机器指令执行
+ JIT（Just In Time）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言

![](img/JVM_33.png)

#### 机器码、指令、汇编语言

**机器码**

+ 各种二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它来编写程序，这就是机器语言
+ 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出错
+ 用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快
+ 机器指令于CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同

**指令**

+ 由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。
+ 指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好
+ 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同

**指令集**

+ 不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集
+ 如常见的
  + x86指令集，对应的是x86架构的平台
  + ARM指令集，对应的是ARM架构的平台

**汇编语言**

+ 由于指令的可读性还是太差，于是人们又发明了汇编语言
+ 在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Lable）代替指令或操作数的地址
+ 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令，由于计算机只认指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行

**高级语言**

+ 为了使计算机用户编程序更加容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言
+ 当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序

![](img/JVM_34.png)

**字节码**

+ 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码
+ 字节码主要是为了实现特定软件运行和软件环境，与硬件环境无关
+ 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译为字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令，字节码的典型应用为Java bytecode

#### 解释器

+ 解释器真正意义上所承担的角色就是一个运行时翻译者，将字节码文件中的内容翻译为对应平台的本地机器指令执行
+ 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录下一条需要被执行的字节码指令执行解释操作

#### JIT编译器

**Java代码的执行分类**

+ 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行
+ 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行

**Hotspot JVM的执行方式**

当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待及时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率

**概念解释**

+ Java语言的编译期其实是一段不确定的操作过程，因为他可能是指一个**前端编译器**把.java文件转变成.class文件的过程
+ 也可能是指虚拟机的**后端运行期编译器**（JIT编译器）把字节码转变成机器码的过程
+ 还可能是指使用静态提前编译器（AOT编译器，Ahead of Time）直接把.Java文件编译成本地机器代码的过程

**热点代码及探测方式**

当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用**执行的频率**而定。关于那些需要被编译为本地代码的字节码，也被称之为**热点代码**，JIT编译器在运行时会针对那些频繁被调用的热点代码做出**深度优化**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能

+ **一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为热点代码**，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。

+ 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些热点代码编译为本地机器执行指令。这里主要依靠**热点探测功能**。

+ **目前HotSpot VM采用的热点探测方式是基于计数器的热点探测**

+ 采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为

  + 方法调用计数器（Invocation Counter）

    方法调用计数器用于统计方法的调用次数，默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译

    这个阈值可以通过虚拟机参数**-XX:CompileThreshold**来人为设置

    当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超阈值，那么将会向即时编译器提交一个该方法的代码编译请求

    ![](img/JVM_35.png)

    **热度衰减**

    如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即**一段时间之内方法被调用的次数**。当**超过一定时间限度**，如果方法的调用次数仍然不足以让他提交给即时编译器编译，那这个方法的调用计数器就会被**减少一半**，这个过程称为方法调用计数器热度的**衰减**（Counter Decay），而这段时间就被称为此方法统计的半衰周期（Counter Half Life Time）

    进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数**-XX:-UseCounterDecay**来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码

    另外，可以使用**-XX:CounterHalfLifeTime**参数设置半衰周期的时间，单位是秒

  + 回边计数器（Back Edge Counter）

    回边计数器则用于统计循环体执行的循环次数，在字节码中遇到控制流向后跳转的指令称为回边（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译

    ![](img/JVM_36.png)



**Hotspot VM可以设置程序执行方式**

缺省情况下Hotspot VM采用解释器与即时编译器共存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。

+ **-Xint**：完全采用解释器模式执行程序
+ **-Xcomp**：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
+ **-Xmixed**：采用解释器+即时编译器的混合模式共同执行程序

**Hotspot VM中JIT分类**

在Hotspot VM中有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器。

+ -client：指定Java虚拟机运行在Client模式下，并使用C1编译器，C1编译器会对字节码进行**简单可靠的优化，耗时短**，以达到更快的编译速度
+ -server：指定Java虚拟机运行在Server模式下，并使用C2编译器。C2进行**耗时较长的优化，以及激进优化**，但优化的代码执行效率更高

**C1和C2编译器不同的优化策略**

+ 在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化，冗余消除
  + 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
  + 去虚拟化：对唯一的实现类进行内联
  + 冗余消除：在运行期间把一些不会执行的代码折叠掉
+ C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化
  + 标量替换：用标量值代替聚合对象的属性值
  + 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
  + 同步消除：清除同步操作，通常指synchronized

分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行优化，不过在Java7版本之后，一旦开发人员在程序中显式指定命令-server时，默认将会开启分层策略，由C1编译器和C2编译器相互协作共同来执行编译任务

JDK10起，Hotspot又加入一个全新的即时编译器：Graal编译器，编译效果短短几年就追平了C2编译器，目前，带着实验状态标签，需要使用开关参数-XX:+UnlockExperimentalVMOptions  -XX:+UseJVMCICompiler去激活，才可以使用

JDK9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler），Java9引入了实验性AOT编译工具jaotc，它借助了Graal编译器，将所输入的Java类文件转换为字节码，并存放至生成的动态共享库中。

所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的是，在程序运行之前，便将字节码转换为机器码的过程

+ 最大好处：Java虚拟机加载已经预编译成二进制库，可以直接运行。不必等待即时编译器的预热，减少Java应用给人带来第一次运行慢的不良体验
+ 缺点：破坏了Java一次编译，到处运行，必须为每个不同硬件、OS编译对应的发行包，降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知，还需要继续优化中，最初只支持Linux64 java base

### 13. StringTable

#### String的基本特性

+ String：字符串，使用一对""引起来表示
+ String声明为final的，不可被继承
+ String实现了Serializable接口，表示字符串是支持序列化的，实现了comparable接口，表示String可以比较大小
+ String在jdk8及以前内部定义了final char[] value用于存储字符串数据，jdk9时改为byte[]
+ String：代表不可变的字符序列。简称：不可变性
  + 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
  + 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
  + 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
+ 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中
+ 字符串常量池中是不会存储相同内容的字符串的
  + **String的String Pool是一个固定大小的Hashtable**，默认值大小长度是1009.如果放进String Pool的string非常多，就会造成hash冲突严重，从而导致链表会很长，而链表长了之后直接会造成的影响就是当调用String.intern时性能会大幅下降
  + 使用**-XX:StringTableSize**可设置StringTable的长度
  + jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTableSize设置没有要求
  + 在jdk7中，StringTable的长度默认值是60013，StringTableSize设置没有要求
  + jdk8开始，设置StringTable的长度的话，1009是可设置的最小值

#### String的内存分配

+ 在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念
+ 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊，他的主要使用方法有两种
  + 直接使用双引号声明出来的String对象会直接存储在常量池中
  + 如果不是双引号声明的String对象，可以使用String提供的intern()方法
+ Java6及以前，字符串常量池存放在永久代
+ Java7中将字符串常量池的位置调整到Java堆内
  + 所有的字符串都保存在堆中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了
  + 字符串常量池概念原本使用的比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用String.intern()
+ java8元空间，字符串常量在堆中

#### 字符串拼接操作

+ 常量与常量的拼接结果在常量池，原理是编译期优化
+ 常量池中不会存在相同内容的常量
+ 只要其中有一个是变量，结果就在堆中，变量拼接的原理时StringBuilder
+ 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址
+ 字符串拼接操作不一定使用的是StringBuilder，如果拼接符号左右两边都是字符串常量或常量引用（final修饰），则仍然使用编译期优化，即非StringBuilder的方式

#### intern()的使用

如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中

+ jdk1.6中，将这个字符串对象尝试放入串池
  + 如果串池中有，则并不会放入。返回已有的串池中的对象的地址
  + 如果没有，会把**此对象复制一份**，放入串池，并返回串池中的对象地址
+ jdk1.7起，将这个字符串对象尝试放入串池
  + 如果串池中有，则并不会放入。返回已有的串池中的对象的地址
  + 如果没有，则会把**对象的引用地址复制一份**，放入串池，并返回串池中的引用地址
+ 使用intern()测试执行效率（空间上）：对于程序中大量存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间

```java
String s = new String("1");
s.intern();//调用此方法前，字符串常量池中已经存在了
String s2 = "1";
System.out.println(s == s2);//jdk6:false  jdk7/8:false

String s3 = new String("1") + new String("1");
s3.intern();//调用此方法前，字符串常量池中不存在
String s4 = "11";
System.out.println(s3 == s4);//jdk6:false  jdk7/8:true

String s3 = new String("1") + new String("1");
String s4 = "11";
String s5 = s3.intern();
System.out.println(s3 == s4);//false
System.out.println(s5 == s4);//true

String s = new String("a") + new String("b");
String s2 = s.intern();
System.out.println(s2 == "ab");//jdk6:true  jdk8:true
System.out.println(s == "ab");//jdk6:false  jdk8:true
```

**new String("ab")会创建几个对象**

两个，一个对象使new关键字在堆空间创建的，另一个对象是字符串常量池中的对象。字节码指令ldc

**new String("a")+new String("b")会创建几个对象**

1. new StringBuilder()
2. new String("a")
3. 常量池中的a
4. new String("b")
5. 常量池中的b
6. StringBuilder的toString()，new String("ab")，强调一下，toString()的调用，在字符串常量池中没有生成"ab"

#### G1中的String去重操作

+ 背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：
  + 堆存活数据集合里面String对象占了25%
  + 堆存活数据集合里面重复的String对象有13.5%
  + String对象的平均长度是45
+ 这个项目将在G1垃圾回收器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存
+ 实现
  + 当垃圾回收器工作的时候，会访问堆上存活的对象，对每一个访问的对象都会检查是否是候选的要去重的String对象
  + 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象
  + 使用一个hashtable来记录所有被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否存在一个一模一样的char数组
  + 如果存在，String对象会调整引用那个数组，释放对原来数组的引用，最终会被垃圾收集器回收掉
  + 如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了
+ 命令行选项
  + UseStringDeduplication (bool)：开启String去重，默认是不开启的，需要手动开启
  + PrintStringDeduplicationStatistics (bool)：打印详细的去重统计信息
  + StringDeduplicationAgeThreshold (uintx)：达到这个年龄的String对象被认为是去重的候选对象

### 14. 垃圾回收概述

#### 什么是垃圾

垃圾是指在**运行程序中没有任何指针指向的对象**，这个对象就是需要被回收的垃圾。

如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用，甚至可能导致内存溢出

#### 为什么需要GC

+ 对于高级语言来讲，一个基本认知是如果不进行垃圾回收，内存迟早会被消耗完，因为不断第分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫
+ 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存转移到堆的一端，以便JVM将整理出来的内存分配给新的对象
+ 随着应用程序所应付的业务越来越庞大、复杂、用户越来越多，没用GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化

#### Java垃圾回收机制

+ 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低了内存泄漏和内存溢出的风险，自动内存管理机制将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发
+ 垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收，其中，Java堆是垃圾收集器的工作重点
+ 从次数上讲：频繁收集Young区，较少收集Old区，基本不动Perm区（或元空间）

### 15. 垃圾回收的相关算法

**垃圾标记阶段：对象存活判断**

+ 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是死亡对象，只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段
+ 当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡
+ 判断对象存活一般有两种方式：引用计数算法和可达性分析算法

#### 垃圾标记阶段的算法之引用计数算法

+ 引用计数法（Reference Counting）比较简单，对每个对象保存一个整型的**引用计数器属性，用于记录对象被引用的情况**
+ 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减一。只要对象A的引用计数器为0，即表示对象A不可能再被使用，可进行回收
+ 优点：**实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟**
+ 缺点：
  + 他需要单独的字段存储计数器，这样的做法增加了**存储空间的开销**
  + 每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销
  + 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法

**循环引用**

![](img/JVM_37.png)

#### 垃圾标记阶段的算法之可达性分析算法

+ 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地**解决引用计数算法中循环引用的问题，防止内存泄漏的发生**

+ 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫**追踪性垃圾收集**（Tracing Garbage Collection）

+ 所谓GC Roots根集合就是一组必须活跃的引用，在Java语言中，GC Roots包括以下几类元素

  + 虚拟机栈中的引用的对象。比如各个线程被调用的方法中使用到的参数、局部变量等
  + 本地方法栈内JNI（通常说的本地方法）引用的对象
  + 方法区中类静态属性引用的对象
  + 方法区中常量引用的对象。字符串常量池（String Table）里的引用
  + 所有被同步锁synchronized持有的对象
  + Java虚拟机内部的引用。基本数据类型对应的Class对象，一些常驻的异常对象（NullPointerException、OutOfMemoryError），系统类加载器
  + 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

  除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）

  如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性

+ 小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，他保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那他就是一个Root

+ 基本思路

  + 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达
  + 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜素所走过的路径称为引用链（Reference Chain）
  + 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象
  + 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象

+ 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保证一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须Stop The World的一个重要原因，即使是号称不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的

#### 对象的finalization机制

+ Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑
+ 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法
+ finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等

+ 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：

  + 在finalize()时可能会导致对象复活
  + finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会
  + 一个糟糕的finalize()会严重影响GC的性能

+ 从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++的析构函数

+ 由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态：

  如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要回收。但事实上，也并非是非死不可，这时候他们暂时处于缓刑阶段。一个无法触及的对象有可能在某一条件下复活自己，如果这样，那么对他的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态，如下：

  + 可触及的：从根节点开始，可以达到这个对象
  + 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活
  + 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因此finalize()只会被调用一次

  以上三种状态中，是由于finalize()方法的存在，进行的区分，只有在对象不可触及时才可以被回收

判定一个对象objA是否可回收，至少要经历两次标记的过程：

1. 如果对象objA到GC Roots没有引用链，则进行第一次标记
2. 进行筛选，判断此对象是否有必要执行finalize()方法
   1. 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为没有必要执行，objA被判定为不可触及的
   2. 如果objA重写了finalize()方法，且还未被执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发器finalize()方法
   3. **finalize()方法是对象逃脱死亡的最后机会**，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出即将回收集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次

#### MAT与JProfiler的GC Roots溯源

MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。MAT是基于Eclipse开发的，是一款免费的性能分析工具。

**获取dump文件**

1. 命令行使用jmap

![](img/JVM_38.png)

2. 使用JVisualVM导出
   + 捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件
   + 可通过以下方法捕获heap dump：
     + 在左侧Application子窗口中右击相应的应用程序，选择heap dump
     + 在Monitor子标签页中点击heap dump按钮
   + 本地应用程序的heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的application栏中对应一个含有时间戳的节点。右击这个节点选择save as即可将heap dump保存到本地

#### 清除阶段：标记-清除算法

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存

目前在JVM中比较常见的三种垃圾收集算法是**标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）**

+ 执行过程

  当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也称stop the world），然后进行两项工作，第一项是标记，第二项是清除

  + 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象
  + 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则进行回收

+ 缺点：效率不算高，在进行GC的时候，，需要停止整个应用程序，导致用户体验差，这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表

+ 何为清除？所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放

#### 垃圾清除阶段算法之复制算法

+ 核心思想：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
+ 优点：
  + 没有标记和清除过程，实现简单，运行高效
  + 复制过去以后保证空间的连续性，不会出现碎片问题
+ 缺点：
  + 需要两倍的内存空间
  + 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管时内存占用或者时间开销也不小
+ 特别的：如果系统中的存活对象多，垃圾对象很少，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行
+ 应用场景：在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比高。所以现在的商业虚拟机都是用这种收集算法回收新生代

#### 垃圾清除阶段算法之标记-压缩算法

+ 执行过程
  + 第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象
  + 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后清理边界外所有空间
+ 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把他称为标记-清除-压缩算法。二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
+ 优点：
  + 消除了标记-清除算法中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可
  + 消除了复制算法中，内存减半的高额代价
+ 缺点：
  + 从效率上来说，标记-整理算法要低于复制算法
  + 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
  + 移动过程中，需要全程暂停用户应用程序。即：STW

![](img/JVM_39.png)

#### 分代收集算法

前面所有这些算法中，并没有一种算法可以完全替代其他算法，他们都具有自己独特的优势和特点。分代收集算法应运而生。

分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收效率

几乎所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的.

在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点

+ 年轻代

  年轻代特点：区域相对老年代较小，对象生命周期、存活率低，回收频繁

  这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得以缓解

+ 老年代

  老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁

  这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除与标记-整理的混合实现

  Mark阶段的开销与存活对象的数量成正比

  Sweep阶段的开销与所管理区域的大小

  compact阶段的开销与存活对象的数据成正比

以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理

#### 增量收集算法、分区算法

**增量收集算法**

+ 基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成
+ 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作
+ 缺点：使用这种方式，由于垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降

**分区算法**

+ 一般来说，相同的条件下，堆空间越大，一次GC所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿
+ 分代算法将按照对象的生命周期长短划分为两个部分，分区算法将整个堆空间划分为连续的不同小区间，每个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间

### 16. 垃圾回收相关概念

#### System.gc()的理解

+ 在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC,，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存
+ 然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用
+ JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过麻烦了，在一些特殊情况下，如我们正在编写一个性能基准，我们可以在允许之间调用System.gc()
+ System.runFinalization()：强制调用失去引用的对象的finalize()方法

#### 内存溢出（OOM）与内存泄漏

**内存溢出**

+ javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存
+ 首先说没有内存的情况：说明Java虚拟机的堆内存不够。原因有二：
  + Java虚拟机的堆内存设置不够
  + 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）
+ 在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理空间，例如在引用机制分析中，涉及到JVM回去尝试回收软引用指向的对象等
+ 当然，也不是任何情况下垃圾收集器都会被触发的，比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError

**内存泄漏（Memory Leak）**

也称作存储泄露，严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏

但实际情况很多时候一些不太好的实践会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的内存泄漏

尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM异常，导致程序崩溃

注意这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小

举例：

1. 单例模式

   单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。

2. 一些提供close的资源未关闭导致内存泄漏

   数据库连接（dataSource.getConnection()），网络连接（socket）和io连接必须手动close，否则是不能被回收的

#### Stop The World

+ 简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。
+ 可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。
  + 分析工作必须在一个能确保一致性的快照中进行
  + 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
  + 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
+ 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所有我们需要减少STW的发生
+ STW事件与采用哪款GC无关，所有的GC都有这个事件
+ 哪怕是G1也不能完全避免STW情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间
+ STW是JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉
+ 开发中不要用System.gc()；会导致STW的发生

#### 垃圾回收的并行与并发

**并发**

+ 在操作系统中，是指一个时间段有几个程序都处于已启动运行到运行完毕之间，且这几个程序都在同一个处理器上运行
+ 并发不是真正意义上的同时进行，只是CPU把一个时间段划分为几个事件片段，然后在这几个时间区间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行

**并行**

+ 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行
+ 其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行
+ 适合科学计算，后台处理等弱交互场景 

**二者对比**

并发，指的是多个事情，在同一时间段内同时发生了

并行，指的是多个事情，在同一时间点上同时发生了

并发的多个任务之间是相互抢占资源的

并行的多个任务之间是不相互抢占资源的

只有在多CPU或者一个CPU多核的情况下，才会发生并行，否则，看似同时发生的事情，其实都是并发执行的

**并行和并发，在谈论垃圾回收器的上下文语境中，他们可以解释如下：**

+ 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态
+ 串行（Serial）：相较于并行的概念，单线程执行，如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收，回收完，再启动程序中的线程。
+ 并发（Concurrent）：指用户线程与垃圾回收线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收器在执行时不会停顿用户程序的运行

#### 安全点与安全区域

**安全点**

程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为安全点（Safepoint）

Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据是否具有让程序长时间执行的特征为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等

**如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？**

+ 抢先式中断：（目前没有虚拟机采用了）

  首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点

+ 主动式中断：

  设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起

**安全区域**

Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序不执行的时候呢？例如线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，走到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决

**安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的**。我们也可以把Safe Region看做是被扩展了的Safepoint

实际执行时：

1. 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程
2. 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止

#### 强引用-不回收

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），这4种引用强度依次逐渐减弱。除强引用外，其他三种引用均可在java.lang.ref包种找到

+ 强引用（Strong Reference）：最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似Object obj=new Object()这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象

+ 软引用（Soft Reference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常

  ```java
  SoftReference<User> userSoftRef = new SoftReference<User>(new User(1,"songhk"));
  ```

+ 弱引用（Weak Reference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象

+ 虚引用（Phantom Reference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的**唯一目的就是能在这个对象被收集器回收时收到一个系统通知**

在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型

当在Java语言中使用new操作符并创建一个新对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用

强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象

对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者是显示地将相应（强）引用赋值为null，就可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略

相对的，弱引用、软引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一

#### 软引用-内存不足即回收

软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常

软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存

垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列

类似弱引用，只不过Java虚拟机会尽量让软引用存活的时间长一些，迫不得已才清理

#### 弱引用-发现即回收

弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象

但是，由于垃圾回收器的线程优先级很低，因此，并不一定能很快地发现持有弱引用的对象，这种情况下，弱引用对象可以存在较长时间

弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况

软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用

弱引用对象如软引用对象最大区别接在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收

#### 虚引用-对象回收跟踪

也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个

一个对象是否有虚引用的存在，完全不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收

他不能单独使用，也无法通过虚引用来获取被引用的对象，当试图通过虚引用的get()方法取得对象时，总是null

为对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知

虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况

由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录

#### 终结器引用（final reference）

+ 它用以实现对象的finalize()方法，也可以称为终结器引用
+ 无需手动编码，其内部配合引用队列使用
+ 在GC时，终结器引用入队，由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象

### 17. 垃圾回收器

#### GC分类与性能指标

+ 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器
  + 串行回收指的是在同一时间段内只允许有一个CPU用来执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中。在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器
  + 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了运用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了STW机制
+ 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器
  + 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间
  + 独占式垃圾回收器（STW）一旦运行，就停止应用程序中的所有用户线程，直至垃圾回收过程完全结束
+ 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器
  + 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，清除回收后的碎片
  + 非压缩式的垃圾回收器不进行这步操作
+ 按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器

**评估GC的性能指标**

+ **吞吐量**：运行用户代码的时间占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）
+ 垃圾收集开始：吞吐量的补数，垃圾收集所占用时间与总运行时间的比例
+ **暂停时间**：执行垃圾收集时，程序的工作线程被暂停的时间
+ 收集频率：相对于应用程序的执行，收集操作发生的频率
+ **内存占用**：Java堆区所占的内存大小
+ 快速：一个对象从诞生到被回收所经历的时间

**吞吐量vs暂停时间**

+ 高吞吐量较好是因为这会让应用程序的最终用户感觉只有应用程序线程在做生产性工作。直觉上，吞吐量越高程序运行越快

+ 低延迟时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户的体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序
+ 不幸的是高吞吐量和低暂停时间是一对相互竞争的目标
  + 因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行效率，但是这样会导致GC需要更长的暂停时间来执行内存回收
  + 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降
+ 现在标准：在最大吞吐量优先的情况下，降低停顿时间

#### 不同的垃圾回收器概述

![](img/JVM_40.png)

+ 串行回收器：Serial、Serial Old
+ 并行回收器：ParNew、Parallel Scavenge、Parallel Old
+ 并发回收器：CMS、G1

![](img/JVM_41.png)

+ 新生代收集器：Serial、ParNew、Parallel Scavenge
+ 老年代收集器：Serial Old、Parallel Old、CMS
+ 整堆收集器：G1

**垃圾收集器的组合关系**

![](img/JVM_42.png)

+ jdk8中取消了红色虚线组合

+ jdk14取消了绿色虚线组合，删除CMS垃圾回收器
+ Serial Old作为CMS出现Concurrent Mod Failure失败的后备方案

**如何查看默认的垃圾收集器**

+ -XX:+PrintCommandLineFlages：查看命令行相关参数（包含使用的垃圾收集器）
+ 使用命令行指令：jinfo -flag  相关垃圾回收器参数  进程ID

#### Serial回收器：串行回收

+ Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择
+ Serial收集器作为Hotspot中Client模式下的默认新生代垃圾收集器。
+ Serial收集器采用复制算法、串行回收和STW机制的方式执行内存回收
+ 除年轻代之外，Serial Old收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和STW机制，只不过内存回收算法使用的是标记-压缩算法
  + Serial Old是运行在Client模式下默认的老年代的垃圾回收器
  + Serial Old在Server模式下主要有两个用途：1.与新生代的Parallel Scavenge配合使用。 2.作为老年代CMS收集器的后备垃圾收集方案
+ 这个收集器是一个单线程的收集器，但它的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，知道他收集结束

![](img/JVM_43.png)

+ 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率
+ 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短的时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的
+ 在hotspot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器，等价于新生代用Serial GC，且老年代用Serial Old GC

#### ParNew回收器：并行回收

+ 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本

+ ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法，STW机制

+ ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器

  ![](img/JVM_44.png)

  + 对于新生代，回收次数频繁，使用并行方式高效
  + 对于老年代，回收次数少，使用串行方式节省资源（CPU并行需要切换线程，串行可以省去切换线程的资源）

+ 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？

  + ParNew收集器运行在多核CPU的环境下，由于可用充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量
  + 但是在单个CPU环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销

+ 除Serial外，目前只有ParNew GC能与CMS收集器配合工作

+ 在程序中，开发人员可以通过选项-XX:+UseParNewGC手动指定使用ParNew收集器进行内存回收任务。他表示年轻代使用并行收集器，不影响老年代

+ -XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数

#### Parallel回收器：吞吐量优先

+ hotspot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和STW机制
+ 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器
+ 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别
+ 高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序
+ Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器
+ Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和STW机制

![](img/JVM_45.png)

+ 在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错
+ 在Java8中，默认是此垃圾回收器
+ -XX:+UseParallelGC：手动指定年轻代使用Parallel并行收集器执行内存回收任务
+ -XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。
  + 分别适用于新生代和老年代。默认jdk8是开启的
  + 上面两个参数，默认开启一个，另一个也会开启（互相激活）
+ -XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以免过多的线程影响垃圾收集性能
+ 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量
+ 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8
+ -XX:MaxGCPauseMillis：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒
  + 为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数
  + 对于用户来讲，停顿时间越短越好。但在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制
  + 该参数使用需谨慎
+ -XX:GCTimeRatio：垃圾收集时间占总时间的比例（=1/（N+1）），用于衡量吞吐量的大小
  + 取值范围（0，100），默认值99，也就是垃圾回收时间不超过1%
  + 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Ratio参数就容易超过设定的比例
+ -XX:+UseAdaptiveSizePolicy：设置Parallel Scavenge收集器具有自适应调节策略
  + 在这种模式下，年轻代大小、Eden和Survivor的比例、晋升老年代的对象年龄参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点
  + 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作

#### CMS回收器：低延迟

+ 在JDK1.5时期，hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是hotspot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作
+ CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验
  + 目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求
+ CMS垃圾收集器采用标记-清除算法，并且也会STW
+ 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个

![](img/JVM_46.png)

+ CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段

  + 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为STW机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这里的速度非常快
  + 并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
  + 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉执行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍微长一些，但也远比并发标记阶段的时间短，暂停用户线程，会STW
  + 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所有这个阶段也是可以与用户线程同时并发的

+ 尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行STW机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要STW，只是尽可能地缩短暂停时间

+ 由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的

+ 另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现溢出Concurrent Mode Failure失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了

+ CMS收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞技术，而只能够选择空闲列表执行内存分配

+ 为什么不使用标记-压缩（Mark Compact）算法?

  因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用？要保证用户线程能继续执行，前提是它运行的资源不受影响。Mark Compact更适合STW场景下使用

+ CMS优点：并发收集、低延迟

+ CMS弊端

  + 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC
  + CMS收集器对CPU资源非常敏感。在并发阶段，他虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢。总吞吐量会降低
  + CMS收集器无法处理浮动垃圾。可能出现Concurrent Mode Failure失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象继续标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间

+ -XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。开启该参数后会自动将-XX:+UserParNewGC打开。即：ParNew（Young区用）+CMS（Old区用）+Serial Old的组合

+ -XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。

  + JDK5及以前版本的默认值为68，即当老年代空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%
  + 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数

+ -XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了

+ -XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理

+ -XX:ParallelCMSThreads：设置CMS的线程数量

  + CMS默认启动的线程数是（ParallelGCThreads+3）/4
  + ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕

+ 小结

  + 如果你想要最小化地使用内存和并行开销，请选择Serial GC
  + 如果你想要最大化应用程序的吞吐量，请选择Parallel GC
  + 如果你想要最小化GC的中断或停顿时间，请选择CMS GC

+ JDK9新特性：CMS被标记为Deprecate

  + 如果对JDK9及以上版本的hotspot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器，用户会收到一个警告信息，提示CMS未来将会被废弃

+ JDK14新特性：删除CMS垃圾回收器

  + 移除了CMS垃圾收集器，如果在JDK14中使用-XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM

#### G1回收器：区域化分代式

**为什么名字叫Garbage First(G1)?**

+ 因为G1是一个并行回收器，他把堆内存分割为很多不相关的区域（Region）（物理上是不连续的）。使用不同的Region来表示Eden、幸存者0区、幸存者1区，老年代等
+ G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region
+ 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）

G1是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征

JDK1.7版本正式启用，移除了Experimental的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为全功能的垃圾收集器，与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在JDK8中还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用

**G1回收器的特点**

+ 并行与并发

  + 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
  + 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

+ 分代收集

  + 从分代上看，G1依然属于分代型垃圾回收器，他会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上来看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量
  + 将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代
  + 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代

+ 空间整合

  + CMS：标记-清除算法、内存碎片、若干次GC后进行一次碎片整理
  + G1将内存划分为一个个的Region，内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显

+ 可预测的停顿时间模型（即：软实时soft real-time）

  这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒

  + 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能够得到较好的控制
  + G1跟踪各个Region里面垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率
  + 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多

+ 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS高。从经验上来说，在小内存的应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势，平衡点在6-8GB之间

**G1回收器的参数设置**

+ -XX:+UseG1GC：手动指定使用G1收集器执行内存回收任务
+ -XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000
+ -XX:MaxGCPauseMills：设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不能保证达到）。默认值是200ms
+ -XX:ParallelGCThread：设置STW工作线程数的值。最多设置为8
+ -XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右
+ -XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。

**G1回收器常见操作步骤**

G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：

+ 第一步：开启G1垃圾收集器
+ 第二步：设置堆的最大内存
+ 第三步：设置最大的停顿时间

G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发

**G1回收器的适用场景**

+ 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）
+ 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案。如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）
+ 用来替换掉JDK1.5中的CMS收集器。在下面情况时，使用G1可能比CMS好
  + 超过50%的Java堆被活动数据占用
  + 对象分配频率或年代提升频率变化很大
  + GC停顿时间过长（长至0.5至1秒）
+ hotspot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用线程帮助加速垃圾回收过程

**分区Region：化整为零**

使用G1收集器时，他将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过-XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变

虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续

![](img/JVM_47.png)

+ 一个region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个region只可能属于一个角色。

+ G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H

  设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果他是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待

  ![](img/JVM_48.png)

  Bump-the-pointer即指针碰撞

  TLAB

**G1回收器的垃圾回收过程**

G1 GC的垃圾回收过程主要包括如下三个环节：

+ 年轻代GC（Young GC）
+ 老年代并发标记过程（Concurrent Marking）
+ 混合回收（Mixed GC）
+ （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收）

应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程：G1的年轻代收集阶段是一个并行的独占式收集器，在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能两个区间都会涉及

当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程

标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的

**Remembered Set  记忆集**

一个region可能被其他任意region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？回收新生代也不得不同时扫描老年代?这样的话会降低Minor GC的效率

解决方法：

+ 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描
+ 每个region都有一个对应的Remembered Set
+  每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作
+ 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）
+ 如果不同，通过CardTable把相关引用信息记录到引用指向对象所在region对应的Remembered Set中
+ 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏

**G1回收过程一：年轻代GC**

JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程，年轻代垃圾回收只会回收Eden区和Survivor区

YGC时，首先G1停止应用程序的执行（STW），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段

+ 第一阶段，扫描根

  根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口

+ 第二阶段，更新RSet

  处理dirty card queue中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用

+ 第三阶段，处理RSet

  识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象

+ 第四阶段，复制对象

  此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阈值会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间

+ 第五阶段，处理引用

  处理Soft，Weak，Phantom，Final，JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而且目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片

**G1回收过程二：并发标记过程**

1. 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC
2. 根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成
3. 并发标记（Concurrent Marking）：整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）
4. 再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning(SATB)
5. 独占清理（cleanup,STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域，为下一阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集
6. 并发清理阶段：识别并清理完全空闲的区域

**G1回收过程三：混合回收**

当越来越多的对象晋升到老年代Old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old region。可以选择哪些Old region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC不是Full GC

![](img/JVM_49.png)

**G1回收过程四：Full GC**

![](img/JVM_50.png)

**G1回收器优化建议**

![](img/JVM_51.png)

#### 7种经典垃圾回收器总结

![](img/JVM_52.png)

**怎么选择垃圾回收器**

![](img/JVM_53.png)

#### GC日志分析

![](img/JVM_54.png)

![](img/JVM_56.PNG)

![](img/JVM_57.png)

### 18.JVM参数

+ -Xss：设置线程的最大栈空间，单位k,m,g，-Xss1024k
+ -Xms用于表示堆区（年轻代+老年代）的起始内存，等价于-XX:InitialHeapSize
+ -Xmx用于表示堆区（年轻代+老年代）的最大内存，等价于-XX:MaxHeapSize
+ -XX:+PrintGCDetails打印GC细节
+ 配置新生代老年代在堆结构的占比
  + 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
  + 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
+ -XX:SurvivorRatio=8设置Eden空间和另外两个Survivor空间缺省所占的比例，默认8:1:1
+ -XX:-UseAdaptiveSizePolicy：关闭自适应的内存分配策略
+ -Xmn设置新生代最大内存大小，一般不设置
+ -XX:MaxTenuringThreshold设置对象晋身到老年代的年龄阈值，默认15
+ -XX:UseTLAB设置是否开启TLAB空间
+ -XX:TALBWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小
+ -XX:+PrintFlagsInitial：查看所有的参数的默认初始值
+ -XX:+PrintFlagsFinal：查看所有参数的最终值（可能存在修改，不再是初始值）
+ -XX:HandlePromotionFailure：是否设置空间分配担保
+ -XX:+DoEscapeAnalysis显式开启逃逸分析
+ -XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果
+ -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上
+ -XX:MetaspaceSize设置元数据区大小，默认值依赖于平台。windows下，-XX:MetaspaceSize是21M
+ -XX:MaxMetaspaceSize设置元数据区最大值，默认值依赖于平台。windows下，XX:MaxMetaspaceSize的值是-1，即没有限制
+ MaxDirectMemorySize设置直接内存大小，如果不指定，默认与堆的最大值-Xmx参数一致
+ -XX:CompileThreshold设置方法调用计数器阈值
+ -XX:-UseCounterDecay关闭热度衰减
+ -XX:CounterHalfLifeTime设置半衰周期的时间，单位是秒
+ -Xint：完全采用解释器模式执行程序
+ -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
+ -Xmixed：采用解释器+即时编译器的混合模式共同执行程序
+ -XX:StringTableSize可设置StringTable的长度
+ UseStringDeduplication (bool)：开启String去重，默认是不开启的，需要手动开启
+ PrintStringDeduplicationStatistics (bool)：打印详细的去重统计信息
+ StringDeduplicationAgeThreshold (uintx)：达到这个年龄的String对象被认为是去重的候选对象
+ -XX:+PrintCommandLineFlages：查看命令行相关参数（包含使用的垃圾收集器）
+ -XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器，等价于新生代用Serial GC，且老年代用Serial Old GC
+ -XX:+UseParNewGC手动指定使用ParNew收集器进行内存回收任务。他表示年轻代使用并行收集器，不影响老年代
+ -XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数
+ -XX:+UseParallelGC：手动指定年轻代使用Parallel并行收集器执行内存回收任务
+ -XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。分别适用于新生代和老年代。默认jdk8是开启的，上面两个参数，默认开启一个，另一个也会开启（互相激活）
+ -XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以免过多的线程影响垃圾收集性能，在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量，当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8
+ -XX:MaxGCPauseMillis：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒
+ -XX:GCTimeRatio：垃圾收集时间占总时间的比例（=1/（N+1）），用于衡量吞吐量的大小，取值范围（0，100），默认值99，也就是垃圾回收时间不超过1%，与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Ratio参数就容易超过设定的比例
+ -XX:+UseAdaptiveSizePolicy：设置Parallel Scavenge收集器具有自适应调节策略，在这种模式下，年轻代大小、Eden和Survivor的比例、晋升老年代的对象年龄参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点，在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作
+ -XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。开启该参数后会自动将-XX:+UserParNewGC打开。即：ParNew（Young区用）+CMS（Old区用）+Serial Old的组合
+ -XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收

### 中篇-字节码

### 1. class文件结构

**什么是字节码指令（byte code）**

java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（operand）所构成。虚拟机中许多指令并不包含操作数，只有一个操作码

**Class类的本质**

任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。Class文件是一组以8位字节为基础单位的二进制流

**Class文件格式**

Class结构不像XML等描述语言，由于它没有任何分隔符号。所以在其中的数据项，无论是字节顺序还是数量，都是被严格限定的，那个字节代表什么含义，长度是多少，先后顺序，都不允许改变。

Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构中只有两种数据类型：**无符号数和表**

+ 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值
+ 表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有表都习惯以_info结尾。用于表述有层次关系的符合数据类型，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明

**Class文件的总体结构**

+ 魔数
+ Class文件版本
+ 常量池
+ 访问标志
+ 类索引、父类索引、接口索引集合
+ 字段表集合
+ 方法表集合
+ 属性表集合

![](img/JVM_58.PNG)

![](img/JVM_59.png)

#### 1. Magic Number（魔数）

+ 每个Class文件开头的4个字节的无符号整数称为魔数（Magic Number）
+ 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符
+ 魔数值固定为0xCAFEBABE。不会改变
+ 如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出错误
+ 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动

#### 2. Class文件版本号

+ 紧接着魔数的4个字节存储的是Class文件的版本号。同样也是4个字节。第5个和和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个就是编译的主版本号major_version

+ 他们共同构成了class文件的格式版本号。譬如某个Class文件的主版本号为M，副版本号为m，那么这个Class文件的格式版本号确定为M.m

+ 版本号和Java解释器的对应关系如下表

  ![](img/JVM_60.png)

+ Java的版本号是从45开始的，jdk1.1之后的每个JDK大版本发布主版本号向上加1

+ 不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出Java.lang.UnsupportedClassVersionError异常

#### 3. 常量池：存放所有常量

+ 常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析有着至关重要的作用
+ 随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个Class文件的基石
+ 在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项
+ 常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的无符号数，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始。
+ Class文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合
+ 常量池表项中，用于存放编译时期生成的各种**字面量和符号引用**，这部分内容将在类加载后进入**方法区的运行时常量池**中存放

##### **constant_pool_count（常量池计数器）**

+ 由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值
+ 常量池容量计数值（u2类型）：**从1开始**，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项
+ 第0项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达"不引用任何一个常量池项目的含义"，这种情况可用索引值0来表示

##### **constant_pool [] （常量池）**

+ constant_pool是一种表结构，以1~constant_pool_count-1为索引。表明了后面有多少个常量项

+ 常量池只要存放两大类常量：**字面量（Literal）和符号引用（Symbolic References）**

  | 常量     | 具体的常量           |
  | -------- | -------------------- |
  | 字面量   | 文本字符串           |
  |          | 声明为final的常量值  |
  | 符号引用 | 类和接口的全限定类名 |
  |          | 字段的名称和描述符   |
  |          | 方法的名称和描述符   |

  **全限定名**

  com/atguigu/test/Demo这个就是类的全限定名，仅仅是把包名的"."替换成"/"，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个";"表示全限定名结束

  **简单名称**

  简单名称是指没有类型和参数修饰的方法或者字段名称，add()方法的简单名称add

  **描述符**

  描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型以及代表无返回类型的void类型都用一个大写字符来表示，而对象类型用字符L加对象的全限定名表示

  | 标识符 | 含义                                                  |
  | ------ | ----------------------------------------------------- |
  | B      | 基本数据类型byte                                      |
  | C      | 基本数据类型char                                      |
  | D      | 基本数据类型double                                    |
  | F      | 基本数据类型float                                     |
  | I      | 基本数据类型int                                       |
  | J      | 基本数据类型long                                      |
  | S      | 基本数据类型short                                     |
  | Z      | 基本数据类型boolean                                   |
  | V      | 代表void类型                                          |
  | L      | 对象类型，比如：Ljava/lang/Object;                    |
  | [      | 数组类型，代表一维数组。比如：double [] [] [] is [[[D |

  用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号内"()"，如方法java.lang.String.toString()的描述符为

  () L/java/lang/String;，方法int abc(int[] x, int y)的描述符为([II) I

  虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。**当虚拟机运行时，需要从常量池中获取对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中**

  **符号引用和直接引用的区别与关联：**

  + **符号引用：**符号引用以**一组符号**来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。**符号引用与虚拟机实现的内存布局无关**，引用的目标并不一定已经加载到了内存中
  + **直接引用：**直接引用可以是直接**指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的**，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了

+ 它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第一个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte（标记字节、标签字节）

![](img/JVM_61.png)

这14种表（或常量项结构）的共同点：表开始的第一位是一个u1类型的标志位，代表当前这个常量使用的是哪种表结构，即哪种常量类型

在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息

这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定，**因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定**

常量池：可以理解为Class文件中的资源仓库，他是Class文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用Class文件空间最大的数据项目之一

**常量池中为什么要包含这些内容？**

Java代码在进行javac编译的时候，并不像C和C++那样有连接这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，**在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。**当虚拟机运行时，需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中

#### 4. 访问标识（access_flag）

+ 在常量池后，紧接着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。各种访问标记如下所示：

  | 标志名称       | 标志值 | 含义                                                         |
  | -------------- | ------ | ------------------------------------------------------------ |
  | ACC_PUBLIC     | 0x0001 | 标志为public类型                                             |
  | ACC_FINAL      | 0x0010 | 标志被声明为final，只有类可以设置                            |
  | ACC_SUPER      | 0x0020 | 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法） |
  | ACC_INTERFACE  | 0x0200 | 标志这是一个接口                                             |
  | ACC_ABSTRACT   | 0x0400 | 是否为abstract类型，对于接口或抽象类来说，此标志为真，其他类型为假 |
  | ACC_SYNTHETIC  | 0x1000 | 标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应） |
  | ACC_ANNOTATION | 0x2000 | 标志这是一个注解                                             |
  | ACC_ENUM       | 0x4000 | 标志这是一个枚举                                             |

+ 类的访问权限通常为ACC_开头的常量

+ 每一种类型的标识都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL

+ 使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并使用这个标记

+ 带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口

  + 如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时他不能再设置ACC_FINAL、ACC_SUPER或ACC_ENUM标志
  + 如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表除ACC_ANNOTATION外的其他标志，当然ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置

+ ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志

  + ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。目前的ACC_SUPER标志在JDK 1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了该标志，那么oracle的Java虚拟机实现会将其忽略

+ ACC_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是源代码生成的

+ 注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那也必须设置ACC_INTERFACE标志

+ ACC_ENUM标志表明该类或其父类为枚举类型

+ 表中没有使用的access_flags标志是为未来扩充而预留的，这些预留的标志在编译器中应该设置为0，Java虚拟机实现也应该忽略他们

#### 5. 类索引、父类索引、接口索引集合

+ 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下

  | 长度 | 含义                         |
  | ---- | ---------------------------- |
  | u2   | this_class                   |
  | u2   | super_class                  |
  | u2   | interfaces_count             |
  | u2   | interfaces[interfaces_count] |

+ 这三项数据来确定这个类的继承关系

  + 类索引用于确定这个类的全限定名
  + 父类索引用于确定这个类的父类的全限定名。由于Java语义不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了Object外，所有的Java类的父类索引都不为0
  + 接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中

+ **this_class（类索引）**

  2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如com/atguigu/Demo。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。

+ **super_class（父类索引）**

  2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是Object类，同时，由于Java不支持多继承，所以其父类只有一个。superclass指向的父类不能是final

+ **interfaces**

  指向常量池索引集合，它提供了一个符号引用到所有已实现的接口

  由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class（当然这里就必须是接口，而不是类）

  + interfaces_count（接口计数器）

    interfaces_count项的值表示当前类或接口的直接超接口数量

  + interfaces  []（接口索引集合）

    interfaces  []中每个成员的值必须是对常量池中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANT_Class_info结构，其中0 <= i <= interfaces_count。在interfaces  []中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序一样

#### 6. 字段表集合

**fields**

+ 用于描述接口或类中声明的变量。字段（field）包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量
+ 字段叫什么名字、字段被定义为什么数据类型，这些信息都是无法固定的，只能引用常量池中的常量来描述
+ 它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private、protected）、是类变量还是实例变量（static修饰符）、是否是常量（final修饰符）等

**注意事项**

+ 字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段
+ Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的

##### **fields_count（字段计数器）**

fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。

fields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段

##### **fields []（字段表）**

+ fields表中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述

+ 一个字段的信息包括以下这些信息，这些信息中，各个修饰符都是布尔值，要么有，要么没有

  + 作用域（public、private、protected修饰符）
  + 是实例变量还是类变量（static修饰符）
  + 可变性（final）
  + 并发可见性（volatile修饰符，是否强制从主内存读写）
  + 可否序列化（transient修饰符）
  + 字段数据类型（基本数据类型、对象、数组）
  + 字段名称

+ 字段表结构

  | 类型           | 名称             | 含义       | 数量             |
  | -------------- | ---------------- | ---------- | ---------------- |
  | u2             | access_flags     | 访问标志   | 1                |
  | u2             | name_index       | 字段名索引 | 1                |
  | u2             | descriptor_index | 描述符索引 | 1                |
  | u2             | attributes_count | 属性计数器 | 1                |
  | attribute_info | attributes       | 属性集合   | attributes_count |

+ 字段表访问标识

  | 标志名称      | 标志值 | 含义                       |
  | ------------- | ------ | -------------------------- |
  | ACC_PUBLIC    | 0x0001 | 字段是否为public           |
  | ACC_PRIVATE   | 0x0002 | 字段是否为private          |
  | ACC_PROTECTED | 0x0004 | 字段是否为protected        |
  | ACC_STATIC    | 0x0008 | 字段是否为static           |
  | ACC_FINAL     | 0x0010 | 字段是否为final            |
  | ACC_VOLATILE  | 0x0040 | 字段是否为volatile         |
  | ACC_TRANSTENT | 0x0080 | 字段是否为transient        |
  | ACC_SYNTHETIC | 0x1000 | 字段是否为由编译器自动产生 |
  | ACC_ENUM      | 0x4000 | 字段是否为enum             |

+ 字段名索引

  根据字段名索引的值，查询常量池中的指定索引项即可

+ 描述符索引

  描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示

  | 标识符 | 含义                                                  |
  | ------ | ----------------------------------------------------- |
  | B      | 基本数据类型byte                                      |
  | C      | 基本数据类型char                                      |
  | D      | 基本数据类型double                                    |
  | F      | 基本数据类型float                                     |
  | I      | 基本数据类型int                                       |
  | J      | 基本数据类型long                                      |
  | S      | 基本数据类型short                                     |
  | Z      | 基本数据类型boolean                                   |
  | V      | 代表void类型                                          |
  | L      | 对象类型，比如：Ljava/lang/Object;                    |
  | [      | 数组类型，代表一维数组。比如：double [] [] [] is [[[D |

+ 一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等，属性个数存放在attribute_count中，属性具体内容存放在attributes数组中

  以常量属性为例，结构为

  ```
  ConstantValue_attribute{
  	u2 attribute_name_index;
  	u4 attribute_length;
  	u2 constantvalue_index;
  }
  ```

  对于常量属性而言，attribute_length值恒为2

#### 7. 方法表集合

methods：指向常量池索引集合，它完整描述了每个方法的签名

+ 在字节码文件中，每一个method_info项都对应着一个类或接口中的方法信息。比如方法的访问修饰符，方法的返回值类型及方法的参数信息
+ 如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来
+ 一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如类（接口）初始化方法<clinit>()和实例初始化方法<init>()）

**使用注意事项**

在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里无法仅仅依靠返回值的不同来对一个方法进行重载。但在Class文件格式中，特征签名的范围要大一些，只要描述符不是完全一致的两个方法就可以共存，也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中

也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同

##### **methods_count（方法计数器）**

methods_count的值表示当前class文件methods表的成员个数。使用两个字节表示

methods表中每个成员都是一个method_info结构

##### **methods [] （方法表）**

+ methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令

+ method_info结构可以表示类或接口中定义的所有方法，包括实例方法、类方法、实例初始化方法

+ 方法表的结构实际跟字段表是一样的

  | 类型           | 名称             | 含义       | 数量             |
  | -------------- | ---------------- | ---------- | ---------------- |
  | u2             | access_flags     | 访问标志   | 1                |
  | u2             | name_index       | 方法名索引 | 1                |
  | u2             | descriptor_index | 描述符索引 | 1                |
  | u2             | attributes_count | 属性计数器 | 1                |
  | attribute_info | attributes       | 属性集合   | attributes_count |

+ 方法表访问标志

  | 标记名        | 值     | 说明                                |
  | ------------- | ------ | ----------------------------------- |
  | ACC_PUBLIC    | 0x0001 | public，方法可以从包外访问          |
  | ACC_PRIVATE   | 0x0002 | private，方法只能本类中访问         |
  | ACC_PROTECTED | 0x0004 | protected，方法在自身和子类可以访问 |
  | ACC_STATIC    | 0x0008 | static，静态方法                    |

#### 8. 属性表集合

属性表集合（attributes）

方法表集合之后的属性表集合，**指的是class文件所携带的辅助信息**，比如该class文件的源文件的名称。以及任何带有RetentionPolicy.CLASS或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及java程序的调试，**一般无须深入了解**

此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息

属性表的集合没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉他不认识的属性

##### **arrtibutes_count（属性计数器）**

attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构

##### **attributes [] （属性表）**

属性表的每个项的值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可

+ 属性的通用格式

  | 类型 | 名称                 | 数量             | 含义       |
  | ---- | -------------------- | ---------------- | ---------- |
  | u2   | attribute_name_index | 1                | 属性名索引 |
  | u4   | attribute_length     | 1                | 属性长度   |
  | u1   | info                 | attribute_length | 属性表     |

  即只需说明属性的名称以及占用位数的长度即可，属性表具体的结构可以去自定义

+ 属性类型

  属性表实际上可以有很多类型，Java8里面定义了23种属性

  下面这些是虚拟机中预定义的属性

  | 属性名称        | 使用位置         | 含义                                                         |
  | --------------- | ---------------- | ------------------------------------------------------------ |
  | Code            | 方法表           | Java代码编译成的字节码指令                                   |
  | ConstantValue   | 字段表           | final关键字定义的常量池                                      |
  | Deprecated      | 类、方法、字段表 | 被声明为deprecated的方法和字段                               |
  | Exceptions      | 方法表           | 方法抛出的异常                                               |
  | EnclosingMethod | 类文件           | 仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 |
  | InnerClass      | 类文件           | 内部表列表                                                   |
  | LineNumberTable | Code属性         | Java源码的行号与字节码指令的对应关系                         |

### 2. 字节码指令集

Java虚拟机的指令由一个字节长度的、代表某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此参数所需参数（称为操作数，Oprands）而构成，由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码

Java虚拟机操作码的长度为一个字节（即0-255），这意味着指令集的操作码总数不可能超过256条

#### 1. 概述

##### **执行模型**

如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当作最基本的执行模型来理解

```
do{
	自动计算PC寄存器的值加1;
	根据PC寄存器的指示位置，从字节码流中取出操作码;
	if(字节码存在操作数) 从字节码流中取出操作数;
	执行操作码所定义的操作;
}while(字节码长度>0)
```

##### **字节码与数据类型**

在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。

也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，他没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象

还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的

大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此大多数boolean、byte、short和char类型数据的操作实际上都是使用相应的int类型作为运行类型

##### **指令分类**

由于完全介绍和学习这些指令需要花费大量时间。为了更快熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类

+ 加载与存储指令
+ 算术指令
+ 类型转换指令
+ 对象的创建与访问指令
+ 方法调用与返回指令
+ 操作数栈管理指令
+ 比较控制指令
+ 异常处理指令
+ 同步控制指令

#### 2. 加载与存储指令

**作用**

加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递

**常用指令**

+ 局部变量压栈指令：将一个局部变量加载到操作数栈：xload、xload_<n>（其中x为i、l、f、d、a（引用类型），n为0到3）
+ 常量入栈指令：将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_ <i>、lconst_<l>、fconst _<f>、dconst _<d>
+ 出栈装入局部变量表指令：将一个数值从操作数栈存储到局部变量表：xstore、xstore_<n>（其中x为i、l、f、d、a，n为0到3）、xastore（其中x为i、l、f、d、a、b、c、s）
+ 扩充局部变量表的访问索引的指令：wide

上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>）。这些指令助记符实际上代表了一组指令（例如iload _<n>代表了iload_0、iload_1、iload_2和iload_3这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，**对于这若干组特殊指令来说，他们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中**

iload_0：将局部变量表中索引为0位置上的数据压入操作数栈中

除此之外，他们的语义和原生的通用指令完全一致（例如iload_0的语义与操作数为0时的iload指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<n>代表非负的整数，<i>代表是int类型的数据，<l>代表long类型，<f>代表float类型，<d>代表double类型

操作byte、char、short和boolean类型数据时，经常用int类型的指令来表示

##### 局部变量压栈指令

局部变量压栈指令将给定的局部变量表中的数据压入操作数栈

这类指令大体可分为：

+ xload_<n>（x为i、l、f、d、a（对象引用），n为0到3）
+ xload（x为i、l、f、d、a）

指令xload_n表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n表示将一个对象引用压栈

指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等

##### 常量入栈指令

常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为const系列、push系列和ldc指令

+ const系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：iconst_<i>（i从-1到5）、lconst _<l>（l从0到1）、fconst _<f>（f从0到2）、dconst _<d>（d从0到1）、aconst_null

  + iconst_m1将-1压入操作数栈
  + iconst_x（x为0到5）将x压入栈
  + lconst_0、lconst_1分别将长整数0和1压入栈
  + fconst_0、fconst_1、fconst_2分别将浮点数0、1、2压入栈
  + dconst_0和dconst_1分别将double型0和1压入栈
  + aconst_null将null压入操作数栈

  从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数、l表示长整数、f表示浮点数、d表示双精度浮点、习惯上用a表示对象引用，如果指令隐含操作的参数，会以下划线形式给出

+ push系列：主要包括bipush和sipush。他们的区别在于接受数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，他们都将参数压入栈

+ ldc系列：如果以上指令都不能满足要求，那么可以使用万能的ldc指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈

  类似的还有ldc_w，它接收两个8位参数，能支持的索引范围大于ldc

  如果要压入的元素是long或double类型的，则使用ldc2_w指令，使用方式都是类似的

| 类型                              | 常数指令 | 范围                         |
| --------------------------------- | -------- | ---------------------------- |
| int（boolean、byte、char、short） | iconst   | [-1,5]                       |
|                                   | bipush   | [-128,127]                   |
|                                   | sipush   | [-32768,32767]               |
|                                   | ldc      | any int value                |
| long                              | lconst   | 0,1                          |
|                                   | ldc      | any long value               |
| float                             | fconst   | 0,1,2                        |
|                                   | ldc      | any float value              |
| double                            | dconst   | 0,1                          |
|                                   | ldc      | any double value             |
| reference                         | aconst   | null                         |
|                                   | ldc      | String literal,Class literal |

##### 出栈装入局部变量表指令

出栈装入局部变量表指令用于将操作数中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量表赋值

这类指令主要以store的形式存在，比如xstore（x为i、l、f、d、a）、xstore_n（x为i、l、f、d、a，n为0至3）和xastore（x为i、l、f、d、a，b、c、s）

+ 其中，指令istore_n将从操作数栈中弹出一个整数，并把它赋值给局部变量n
+ 指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置
+ xastore则专门针对数组操作，以iastore为例，它用于给一个int数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置

**一般来说，类似store这样的命令需要带一个参数，用来指明弹出的元素放在局部变量表的第几个位置。**但是，为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放在局部变量表的第1个位置。类似的还有istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置

由于局部变量表前几个位置总是非常常用，因此**这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积**。如果局部变量表很大，需要存储的槽位大于3，可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置

#### 3. 算术指令

**作用：**算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈

**分类：**大体上算术指令可以分为两种，对整型数据进行运算的指令与对浮点类型数据进行运算的指令

**byte、short、char和boolean类型说明**

在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。

**运算模式**

+ 向最接近数舍入模式：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精度结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；
+ 向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果

**NaN值使用**

当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作没有明确的数学定义的话，将会使用NaN值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回NaN;

**所有的算术指令**

加法指令：iadd、ladd、fadd、dadd

减法指令：isub、lsub、fsub、dsub

乘法指令：imul、lmul、fmul、dmul

除法指令：idiv、ldiv、fdiv、ddiv

求余指令：irem、lrem、frem、drem   //remainder：余数

取反指令：ineg、lneg、fneg、dneg     //negation：取反

自增指令：iinc

位运算指令，可分为

+ 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
+ 按位或指令：ior、lor
+ 按位与指令：iand、land
+ 按位异或指令：ixor、lxor

比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp

**比较指令的说明**

+ 比较指令的作用是比较两个元素的大小，并将比较结果入栈
+ 对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，他们的区别在于在数字比较时，若遇到NaN值，处理结果不同
+ 指令lcmp针对long型整数，由于long型整数没有NaN（0.0/0.0）值，故无需准备两套指令

指令fcmpg和fcmpl都从栈中弹出两个操作数，并将它们作比较，设栈顶的元素为v2，栈顶顺位第2位的元素为v1，若v1=v2，则压入0；若v1>v2则压入1；若v1<v2则压入-1

两个指令的不同之处在于，如果遇到NaN值，fcmpg会压入1，而fcmpl会压入-1

#### 4. 类型转换指令

**类型转换指令说明**

类型转换指令可以将两种不同的数值类型进行相互转换

这些转换操作一般用于实现用户代码中的**显示类型转换操作**，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题

##### 1. 宽化类型转换

**转换规则**

Java虚拟机直接支持以下数值的宽化类型转换（widening numeric conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：

+ 从int类型到long、float或者double类型。对应的指令为：i2l、i2f、i2d
+ 从long类型到float、double类型。对应的指令为：l2f、l2d
+ 从float类型到double类型。对应的指令为：f2d

简化为：int --> long --> float --> double

**精度损失问题**

宽化转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long，或者从int转换到double，都不会丢失任何信息，转换前后的值是精确相等的

从int、long类型数值转换到float，或者long类型数值转换到double时，将可能发生精度丢失——可能丢掉几个最低有效位上的值，转换后的浮点数值时根据IEEE754最接近舍入模式所得到的正确整数值

尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常

**补充说明**

**从byte、char和short类型到int类型的宽化类型转换实际上是不存在的。**对于byte类型转为int，虚拟机并没有做实质性的转化处理，只是简单的通过操作数栈交换了两个数据。而将byte转为long时，使用的时i2l，可以看到在内部byte在这里以及等同于int类型处理，类似的还有short类型，这种处理方式有两个特点：

一方面可以减少实际的数据类型，如果short和byte都准备一套指令，那么指令的数量会大增，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将short和byte当作int处理也在情理之中

另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型

##### 2. 窄化类型转换

**转换规则**

Java虚拟机也直接支持以下窄化类型转换：

+ 从int类型至byte、short或者char类型。对应的指令有：i2b、i2c、i2s
+ 从long类型到int类型。对应的指令有：l2i
+ 从float类型到int或者long类型。对应的指令有：f2i、f2l
+ 从double类型到int、long或者float类型。对应的指令有：d2i、d2l、d2f

**精度损失问题**

窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。

尽管数据类型窄化转化可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常

**补充说明**

当一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下转化规则：

+ 如果浮点值是NaN，那转换结果就是int或long类型的0
+ 如果浮点值不是无穷大的化，浮点值使用IEEE754的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long）的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T能所表示的最大或最小正数

将一个double类型窄化为float类型时，将遵循以下转换规则：

通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断：

+ 如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零
+ 如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大
+ 对于double类型的NaN将按照规定转换为float类型的NaN值

#### 5. 对象的创建与访问指令

##### 1. 创建指令

虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令

**创建类实例的指令**

+ new：它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈

**创建数组的指令**

+ newarray：创建基本类型数组
+ anewarray：创建引用类型数组
+ multianewarray：创建多维数组

##### 2. 字段访问指令

对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素

+ 访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic
+ 访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield

##### 3. 数组操作指令

数组操作指令主要有：xastore和xaload指令。具体为：

+ 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload
+ 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore
+ 取数组长度的指令：arraylength，该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈

**说明**

+ 指令xaload表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引i，栈顶顺位第2个元素为数组引用a，该指令会弹出栈顶这两个元素，并将a[i]重新压入堆栈
+ xastore则专门针对数组操作，以iastore为例，它用于一个int数组的给定索引赋值，在iastore执行前，操作数栈顶需要以此准备三个元素：值、索引、数组引用，iastore会弹出3这个值，并将值赋给数组中指定索引的位置

##### 4. 类型检查指令

检查类实例或数组类型的指令：instanceof、checkcast

+ 指令checkcast用于检查类型强制转换是否可以进行，如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常
+ 指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈

#### 6. 方法调用与返回指令

##### 1. 方法调用指令

invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic

+ invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分配），支持多态。这也是Java语言中**最常见的方法分派方式**
+ invokeinterface指令用于**调用接口方法**，他会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用
+ invokespecial指令用于调用一些需要特殊处理的实例方法，包括**实例初始化方法（构造器）、私有方法和父类方法。**这些方法都是静态类型绑定的，不会在调用时进行动态派发
+ invokestatic指令用于调用命名**类中的类方法（static方法）。**这是静态绑定的
+ invokedynamic调用动态绑定的方法，这个是jdk1.7后新加入的指令。用于在执行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的

##### 2. 方法返回指令

方法调用结束前，需要进行返回。方法返回指令是根据方法返回值的类型区分的

+ 包括return（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn
+ 另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用

通过ireturn指令，将当前操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃

如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区

最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者

#### 7. 操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令

+ 将一个或两个元素从栈顶弹出，并且直接废弃：pop、pop2
+ 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2
+ 将栈最顶端的两个Slot数值位置互换：swap。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令
+ 指令nop，是一个非常特殊的指令，他的字节码0x00。和汇编语言中的nop一样，他表示什么都不做。这条指令一般可用于调试、占位等。

这些指令属于通用型，对栈的压入或者弹出无需指明数据类型

**说明**

+ 不带_x指令是复制栈顶数据并压入栈顶。包括两个指令，dup和dup2，dup的系数代表要复制的Slot个数
  + dup开头的指令由于复制1个Slot的数据。例如1个int或1个reference类型数据
  + dup2开头的指令用于复制2个Slot的数据。例如1个long，或2个int，或1个int+1个float类型数据
+ 带_x的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令dup_x1、dup2_x1、dup_x2、dup2_x2。对于带 _x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此
  + dup_x1插入位置：1+1=2，即栈顶2个Slot下面
  + dup_x2插入位置：1+2=3，即栈顶3个Slot下面
  + dup2_x1插入位置：2+1=2，即栈顶3个Slot下面
  + dup2_x2插入位置：2+2=2，即栈顶4个Slot下面
+ pop：将栈顶的1个Slot数值出栈。例如1个short类型数值
+ pop2：将栈顶的2个Slot数值出栈。例如一个double类型数值，或者2个int类型数值

#### 8. 控制转移指令

##### 1. 比较指令（算术指令中比较指令）

##### 2. 条件跳转指令

条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转

条件跳转指令有：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）

它们的统一含义为：弹出栈顶元素，测试他是否满足某一条件，如果满足条件，则跳转到给定位置

| ifeq      | 当栈顶int类型数值等于0时跳转     |
| --------- | -------------------------------- |
| ifne      | 当栈顶int类型数值不等于0时跳转   |
| iflt      | 当栈顶int类型数值小于0时跳转     |
| ifle      | 当栈顶int类型数值小于等于0时跳转 |
| ifgt      | 当栈顶int类型数值大于0时跳转     |
| ifge      | 当栈顶int类型数值大于等于0时跳转 |
| ifnull    | 为null时跳转                     |
| ifnonnull | 不为null时跳转                   |

**注意**

与前面运算规则一致：

+ 对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成
+ 对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转

由于各类型的比较最终都会转为int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的

##### 3. 比较条件跳转指令

比较条件跳转指令类似于比较指令和条件跳转指令的结合体，他将比较和跳转两个步骤合二为一

这类指令有：if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne

其中指令助记符加上if后，以字符i开头的指令针对int型整数操作（也包括short和byte类型），以字符a开头的指令表示对象引用的比较

| if_icmpeq | 比较栈顶两int类型数值大小，当前者等于后者时跳转     |
| --------- | --------------------------------------------------- |
| if_icmpne | 比较栈顶两int类型数值大小，当前者不等于后者时跳转   |
| if_icmplt | 比较栈顶两int类型数值大小，当前者等小于后者时跳转   |
| if_icmpgt | 比较栈顶两int类型数值大小，当前者小于等于后者时跳转 |
| if_icmple | 比较栈顶两int类型数值大小，当前者大于后者时跳转     |
| if_icmpge | 比较栈顶两int类型数值大小，当前者大于等于后者时跳转 |
| if_acmpeq | 比较栈顶两引用类型数值，当结果相等时跳转            |
| if_acmpne | 比较栈顶两引用类型数值，当结果不相等时跳转          |

这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置，同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的两个元素被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句

##### 4. 多条件分支跳转指令

多条件分支跳转指令是专为switch-case语句设计的，主要有tableswitch和lookupswitch

| tableswitch  | 用于switch条件跳转，case值连续   |
| ------------ | -------------------------------- |
| lookupswitch | 用于switch条件跳转，case值不连续 |

从助记符上看，两者都是switch语句的实现，他们的区别是：

+ tableswitch要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，**因此效率比较高**
+ lookupswitch内部存放着每个离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转位置，**因此效率较低**

由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset

指令lookupswitch处理的是离散的case值，但是出于效率考虑，将case-offset按照case值大小排序，给定index时，需要查找与index相等的case，获得其offset，如果找不到则跳转到default。

##### 5. 无条件跳转指令

目前主要的无条件跳转指令为goto，指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处

如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令goto_w，他和goto有相同的作用，但是他接收4个字节的操作数，可以表示更大的地址范围

指令jsr、jsr_w、ret虽然也是无条件跳转的，但主要用于try-finally语句，且已经被虚拟机逐渐放弃

| goto   | 无条件跳转                                                   |
| ------ | ------------------------------------------------------------ |
| goto_w | 无条件跳转（宽索引）                                         |
| jsr    | 跳转到指定16位offset位置，并将jsr下一条指令地址压入栈顶      |
| jst_w  | 跳转到指定32位offset位置，并将jsr_w下一条指令地址压入栈顶    |
| ret    | 返回由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用） |

#### 9. 异常处理指令

##### 1. 抛出异常指令

在Java程序中显示抛出异常的操作（throw语句）都是由athrow指令来实现。

除了使用throw语句显示抛出异常情况外，**JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出**

正常情况下，操作数栈的压入弹出都是一条条指令完成的，唯一的例外情况是**在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上**

异常及异常的处理

过程一：异常对象的生成过程 ---> throw（手动/自动）---> 指令：athrow

过程二：异常的处理：抓抛模型。try-catch-finally ---> 使用异常表

##### 2. 异常处理与异常表

在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（早期使用jsr、ret指令），而是采用异常表来完成的

**异常表**

如果一个方法定义了一个try-catch或try-finally的异常处理，就会创建一个异常表。它包括了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如：

+ 起始位置
+ 结束位置
+ 程序计数器记录的代码处理的偏移地址
+ 被捕获的异常类在常量池中的索引

当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧。并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终结，比如这个线程是main线程

不管什么时候抛出异常，如果异常处理最终匹配了所有的异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标

#### 10. 同步控制指令

Java虚拟机支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor来支持的

##### 1. 方法级的同步

方法级的同步：是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法；

当调用方法时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否设置

+ 如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁
+ 在方法执行期间，执行线程有了同步锁，其他任何线程都无法再获得同一个锁
+ 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放

**说明**

对于同步方法而言，当虚拟机通过方法的访问标识符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter和monitorexit指令是隐式存在的，并未直接出现在字节码中

##### 2. 方法内指定指令序列的同步

同步一段指令集序列：通常是由Java中的synchronized语句块来表示的，jvm的指令集有monitorenter和monitorexit两条指令来支持synchronized关键字的语义

当一个线程进入同步代码块是，它使用monitorenter指令请求进入。如果当前对象的监视器计数器为0，则他会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块

当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之关联，用来判断对象是否被锁定，当监视器被持有后，对象属于锁定状态

指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象，之后monitorenter和monitorexit的锁定和释放都是针对这个对象的监视器进行的

### 3. 类的加载过程详解

在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载

##### 1. Loading(加载)阶段

**加载的理解**

**所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。**所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用

反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射

**加载完成的操作**

**加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。**

在加载类时，Java虚拟机必须完成以下3件事情：

+ 通过类的全名，获取类的二进制数据流
+ 解析类的二进制数据流为方法区内的数据结构（Java类模型）
+ 创建java.lang.Class类的实例，表示该模型。作为方法区这个类的各种数据的访问入口

**二进制流的获取方式**

对于类的二进制数据，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）

+ 虚拟机可能通过文件系统读入一个class后缀文件（最常见）
+ 读入jar、zip等归档数据包，提取类文件
+ 事先存放在数据库中的类的二进制数据
+ 使用类似HTTP之类的协议通过网络进行加载
+ 在运行时生成一段Class的二进制信息等

在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例

如果输入数据不是ClassFile的结构，则会抛出ClassFormatError

**类模型的位置**

加载的类在JVM中创建相应的类结构，类结构会存储在方法区（jdk1.8之前：永久代；jdk1.8之后：元空间）

**Class实例的位置**

类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象

Class类的构造方法是私有的，只有JVM能够创建

java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据、入口。通过Class类提供的接口，可以获得目标类所关联的.class文件中具体的数据结构：方法、字段等信息

**数组类的加载**

创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类的过程：

+ 如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型
+ JVM使用指定的元素类型和数组维度来创建新的数组类

如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public

##### 2. Linking(链接)阶段

**验证阶段（Verification）**

当类加载到系统后，就开始链接操作，验证时链接操作的第一步，它的目的是保证加载的字节码是合法、合理并符合规范的

验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查：

![](/img/JVM_62.png)

验证的内容涵盖了类数据信息的格式验证、语义检查、字节码验证以及符号引用验证等

+ 其中格式验证会和加载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区
+ 格式验证之外的验证操作将会在方法区中进行

链接阶段的验证虽然拖慢了加载速度，但是他避免了在字节码运行时还需要进行各种检查

1. 格式验证：是否以魔数0xCAFEBABE开头，主版本号和副版本号是否在当前Java虚拟机的支持范围内，数据中每一项是否都拥有正确的长度等

2. Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过，比如：

   + 是否所有的类都有父类的存在（在Java里，除了Object外，其他类都应该有父类）
   + 是否一些被定义为final的方法或者类被重写或继承了
   + 非抽象类是否实现了所有抽象方法或者接口方法
   + 是否存在不兼容的方法（比如方法的前面除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；abstract情况下的方法，就不能是final了）

3. Java虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程。他试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：

   + 在字节码的执行过程中，是否会跳到一条不存在的指令
   + 函数的调用是否传递了正确类型的参数
   + 变量的赋值是不是给了正确的数据类型等

   栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量和操作数栈是否有正确的数据类型。但遗憾的是100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是如果通过了这个阶段的检查，也不能说明这个类是

   在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没问题的

4. 校验器还将进行符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的。并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError。此阶段在解析环节才会执行

**准备阶段（Preparation）**

**准备阶段，简言之，为类的静态变量分配内存，并将其初始化为默认值**

当一个类验证通过时，虚拟机将会进入准备阶段，在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。

| 类型      | 默认初始值 |
| --------- | ---------- |
| byte      | (byte)0    |
| short     | (short)0   |
| int       | 0          |
| long      | 0L         |
| float     | 0.0f       |
| double    | 0.0        |
| char      | \u0000     |
| boolean   | false      |
| reference | null       |

注意：Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，boolean的默认值就是false

+ 这里不包含基本数据类型的字段用static final修饰的情况，因为final在编译的时候就会分配了，准备阶段会显示赋值
+ 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中
+ 在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行

**解析阶段（Resolution）**

简言之，将类、接口、字段和方法的符号引用转为直接引用

符号引用就是一些字面量的引用，和虚拟机的内部数据结构和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置

以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。**通过解析操作，符号引用就可以转变为目标方法在类中方法表的位置，从而使得方法被成功调用**

所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构

不过Java虚拟机规范并没有明确要求解析阶段一定要按顺序执行。在hotspot vm中，加载、验证、准备和初始化会按照顺序有条不紊的进行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行

**当在Java代码中直接使用字符串常量时，就会在类中出现CONSTANT_String**，他表示字符串常量，并且会引用一个CONSTANT_UTF8的常量项。**在Java虚拟机内部运行中的常量池中，会维护一张字符串拘留表（intern），他会保存所有出现过的字符串常量，并且没有重复项。**只要以CONSTANT_String形式出现的字符串也都会在这张表中。使用String.intern()方法可以得到一个字符串在拘留表中的引用，因为该表中没有重复项，所以任何字面量相同的字符串的String.intern()方法返回总是相等的

##### 3. Initialization(初始化)阶段

简言之，为类的静态变量赋予正确的初始值

类的初始化是类装载的最后一个阶段，如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中，此时，类才会开始执行Java字节码（**到了初始化阶段，才真正开始执行类中定义的Java程序代码**）

初始化阶段的重要工作时执行类的初始化方法：<clinit>()方法

+ 该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成
+ 它是由类静态成员的赋值语句以及static语句块合并产生的

在加载类之前，虚拟机总是会试图加载该类的父类，因此父类的<clinit>总是在子类<clinit>之前被调用

Java编译器并不会为所有的类都产生<clinit>()初始化方法。哪些类在编译为字节码后，字节码文件中不会包含<clinit>()方法？

+ 一个类中并没有声明任何的类变量，也没有静态代码块时
+ 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时
+ 一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式

**static与final的搭配问题**

使用static + final修饰的字段的显示赋值操作，到底是在哪个阶段进行的赋值？

+ 对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值（直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行
+ 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行

在初始化阶段<clinit>()中赋值的情况：

排除上述的在准备环节赋值的情况之外的情况

最终结论：使用static final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。

**<clinit>()的线程安全性**

对于<clinit>()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性

虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。

正是因为函数<clinit>()带锁线程安全的，因此，如果在一个类的<clinit>方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来他们并没有可用的锁信息

如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<clinit>()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息

**类的初始化情况：主动使用vs被动使用**

Java程序对类的使用分为两种：主动使用和被动使用

**1.主动使用**

意味着会调用类的<clinit>()方法

Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的使用是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成）

1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化
2. 当调用类的静态方法时，即当使用了字节码invokestatic指令
3. 当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）
4. 当使用java.lang.reflect包中的方法反射类的方法时。比如Class.forName("Test")
5. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化
7. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类
8. 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）

当虚拟机初始化一个类时，要求他的所有父类都已经被初始化，但是这条规则并不适用于接口

+ 在初始化一个类时，并不会先初始化它所实现的接口
+ 在初始化一个类接口，并不会先初始化它的父接口

因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化

JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化

**2.被动使用**

除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化

1. 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化，当通过子类引用父类的静态变量，不会导致子类的初始化
2. 通过数组定义类引用，不会触发此类的初始化
3. 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显示赋值了
4. 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化

##### 4. 类的Using(使用)

任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这个3个步骤之后，开发人员可以在程序中访问和调用它的静态类成员信息（比如静态字段、静态方法），或者使用new关键字为其创建对象实例

##### 5. 类的Unloading(卸载)

**类、类加载器、类实例之间的引用关系**

在类加载器的内部实现中，用一个Java集合来存放所加载的类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类加载器之间为双向关联关系

一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象

**类的生命周期**

当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期

一个类何时结束生命周期、取决于代表它的Class对象何时结束生命周期。

![](/IMG/JVM_63.png)

如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载

当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例（可以通过哈希码查看是否是同一个实例）

**类的卸载**

1. 启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm和jls规范）

2. 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类加载器的实例基本上在整个运行期间总能直接或间接的访问到，其达到unreachable的可能性极小
3. 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义 类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）

**方法区的垃圾回收**

方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型

HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收

判定一个常量是否废弃还是相对简单，而要判断一个类型是否属于不再被使用的类的条件就比较苛刻了。需要同时满足下面三个条件：

+ 该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生的子类的实例。
+ 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
+ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而不是和对象一样，没有引用了就必然会回收

### 4. 再谈类的加载器

#### 1. 概述

类加载器是JVM执行类加载机制的前提

ClassLoader的作用：

ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象的实例。然后交给Java虚拟机进行链接、初始化等操作。因此ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可运行，则由Execution Engine决定

类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在OSGi、字节码加解密领域大放异彩。这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将他绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。

**类加载的分类**

类的加载分类：显式加载 vs 隐式加载

class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式

+ 显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName()或this.getClass().getClassLoader().loadClass()加载class对象
+ 隐式加载则是不直接在代码中调用ClassLoader的方法来加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中

**类加载器的必要性**

一般情况下，Java开发人员并不需要在程序中显式的使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：

+ 避免在Java开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题
+ 需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了
+ 开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑

**命名空间**

何为类的唯一性?

对于任意一个类，**都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性**。每一个类加载器，都拥有一个独立的类名称空间：**比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义**。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相同

命名空间

+ 每个类加载器都有自己的命名空间，命名空间由该类加载器即所有的父类加载器所加载的类组成
+ 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
+ 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类

在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本

**类加载机制的基本特征**

+ 双亲委派模型。但不是所有的类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器
+ 可见性，子类加载器可以访问父类加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑
+ 单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器邻居间，同一类型仍然可以被加载多次，因为互相并不可见

#### 2. 类加载器的分类

JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）

从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：

![](/img/JVM_64.png)

+ 除了顶层的启动类加载器外，其余的类加载器都应当有自己的父亲加载器
+ 不同类加载器看似是继承关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用

**启动类加载器（引导类加载器，Bootstrap ClassLoader）**

+ 这个类加载使用C/C++语言实现的，嵌套在JVM内部
+ 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类
+ 并不继承自java.lang.ClassLoader，没有父加载器
+ 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类
+ 加载扩展类和应用程序类加载器，并指定为他们的父类加载器

**扩展类加载器（Extension ClassLoader）**

+ Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
+ 继承于ClassLoader类
+ 父类加载器为启动类加载器
+ 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载

**应用程序类加载器（系统类加载器，AppClassLoader）**

+ java语言编写，由sun.misc.Launcher$AppClassLoader实现
+ 继承于ClassLoader类
+ 父类加载器为扩展类加载器
+ 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
+ 应用程序中的类加载器默认是系统类加载器
+ 他是用户自定义类加载器的默认父加载器
+ 通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器

**用户自定义类加载器**

+ 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式
+ 体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源
+ 通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现
+ 同时，自定义加载器能够实现应用隔离，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想
+ 自定义类加载器通常需要继承于ClassLoader

#### 3. 测试不同的类加载器

每个Class对象都会包含一个定义它的ClassLoader的一个引用

获取ClassLoader的途径

+ 获取当前类的ClassLoader：clazz.getClassLoader()
+ 获得当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()
+ 获得系统的ClassLoader：ClassLoader.getSytemClassLoader()

站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载器压根就不是一个Java类，因此在Java程序中只能打印出空值

数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组的类加载器来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的

#### 4. ClassLoader源码解析

![](/img/JVM_65.png)

除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类

**抽象类ClassLoader的主要方法（内部没有抽象方法）**

+ public final ClassLoader getParent()

  返回该类加载器的超类加载器

+ public Class<?> loadClass(String name) throws ClassNotFoundExcepation

  加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundExcepation异常。该方法中的逻辑就是双亲委派模式的实现

+ protected Class<?> findClass(String name) throws ClassNotFoundExcepation

  查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委派机制，该方法会在检查完父类加载器之后被loadClass()方法调用

  在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委派模式

  需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundExcepation异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的**。一般情况下，在自定义类加载器时，会覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象**

+ protected final Class<?> defineClass(String name, byte[] b, int off, int len)

  根据给定的字节数组b转换为Class实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用

  defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象

  defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象

+ protected final void resolveClass(Class<?> c)

  链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用

+ protected final Class<?> findLoadedClass(String name)

  查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改

+ private final ClassLoader parent

  它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载过程中，ClassLoader可能会将某些请求交予自己的双亲处理

**SecureClassLoader与URLClassLoader**

接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联

前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。**在编写自定义类加载器时，如果没有太过复杂的需求，可以直接继承URLClassLoader类，**这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁

**ExtClassLoader与AppClassLoader**

这两个类都继承自URLClassLoader，使sun.misc.Launcher的静态内部类。sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的

ExtClassLoader并没有重写loadClass()方法，这说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类的loadClass()方法，因此也遵守双亲委派模式

**Class.forName()与ClassLoader.loadClass()**

+ Class.forName()：是一个静态方法，最常用的是Class.forName(String className);根据传入的类的全限定名返回一个Class对象。**该方法在将Class文件加载到内存的同时，会执行类的初始化。**
+ ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。**该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。**该方法因为需要得到一个个ClassLoader对象，所以可以根据需要指定使用哪个类加载器

#### 5. 双亲委派模型

类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全

**定义**

如果一个类加载器在接到加载类的请求时，他首先不会自己尝试去加载这个类，而是把这个请求任务交给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载

**本质**

规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载

**优势与劣势**

双亲委派机制的优势

+ 避免类的重复加载，确保一个类的全局唯一性

  Java类随着他的类加载器一起具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载，当父类已经加载了该类是，就没有必要子ClassLoader再加载一次

+ 保护程序安全，防止核心API被随意篡改

代码支持

双亲委派机制在java.lang.ClassLoader.loader(String ,boolean)接口中体现。该接口的逻辑如下：

1. 先在当前加载器的缓存中查找有无目标类，如果有，直接返回
2. 判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name,false)接口进行加载
3. 反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载
4. 如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类

双亲委派的模型就隐藏在第2步和第3步中

如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String, boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第1步和第4步，那么是不是就能够加载核心类库了呢？

这也不行，因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器亦或是扩展类加载器，最终都必须调用java.lang.ClassLoader.defineClass(String, byte[], int, int ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护

**双亲委派模式的弊端**

检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类

通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题的，但是系统访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。

**结论**

由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。

比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法

**破坏双亲委派机制**

第一次破环双亲委派机制：

双亲委派模型的第一次被破坏其实发生在双亲委派模型出现之前——即JDK1.2面世以前的远古时代。

由于双亲委派模型在JDK1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对这些已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有的代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意义去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的

第二次破环双亲委派机制：线程上下文类加载器

双亲委派模型的第二次被破坏是由这个模型自身的缺陷导致的，双亲委派很好的解决了各个类加载器协作时基础类型的一致性问题（**越基础的类由越上层的加载器进行加载**），基础类型之所以被称为基础，是因为他们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，**如果有基础类型又要调用回用户的代码，那该怎么办呢？**

这并非是不可能出现的事情，一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器完成加载（在JDK1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，他需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface , SPI）的代码，现在问题来了，**启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？**

为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器

有了线程上下文类加载器，程序就可以做一些舞弊的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，**这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，**但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案

![](/img/JVM_66.png)

默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类

第三次破环双亲委派机制：

双亲委派模型的第三次被破坏是由于用户对程序动态性的追求而导致的，如：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等

IBM公司主导的JSR-291（即OSGI R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGI中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGI环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更为复杂的网状结构

当收到类加载请求时，OSGI将按照下面的顺序进行类搜索：

1. 将以java.*开头的类，委派给父类加载器加载
2. 否则，将委派列表名单内的类，委派给父类加载器加载
3. 否则，将Import类表中的类，委派给Export这个类的Bundle的类加载器加载
4. 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载
5. 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
6. 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载
7. 否则，类查找失败

只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的

**热替换的实现**

热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的

但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行方法就是灵活运用ClassLoader

注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的

根据这个特点，可以用来模拟热替换的实现，基本思路如下图：

![](/img/JVM_67.png)

#### 6. 沙箱安全机制

+ 保证程序安全
+ 保护Java原生的JDK代码

Java安全模型的核心就是Java沙箱（sandbox）。什么是沙箱？沙箱是一个限制程序运行的环境

沙箱机制就是将Java代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破环

沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源的访问的限制也可以不一样

所有的Java程序运行都可以指定沙箱，可以定制安全策略。

**JDK1.0时期**

在Java中将程序分为本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于受信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期Java实现中，安全依赖于沙箱（SandBox）机制。如下图JDK1.0安全模型

![](/img/JVM_68.png)

**JDK1.1时期**

JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。

因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。

![](/img/JVM_69.png)

**JDK1.2时期**

![](/img/JVM_70.png)

**JDK1.6时期**

当前最新的安全机制实现，则引入了域（Domain）概念

虚拟机会把所有的代码加载到不同的系统域和应用域。**系统域部分专门负责与关键资源进行交互，**而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限。

![](/img/JVM_71.png)

#### 7. 自定义类的加载器

**为什么要自定义类加载器？**

+ 隔离加载类

  在某些框架内进行中间件与应用之间的模块隔离，把类加载到不同的环境中。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序

+ 修改类加载的方式

  类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载

+ 扩展加载源

  比如从数据库、网络、甚至是电视机机顶盒进行加载

+ 防止源码泄露

  Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码

**常见场景**

+ 实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如：两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架
+ 应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型

**注意**

在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常

**实现方式**

+ Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。
+ 在自定义ClassLoader的子类时候，我们常见的会有两种做法：
  + 方式一：重写loadClass()方法
  + 方式二：重写findClass()方法

这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲，我们最好不要修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用

+ loadClass()这个方法是实现双亲委派模型的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委派的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择
+ 当编写好自定义类加载器后，便可以在程序中调用loadClass()来实现类加载操作

**说明**

+ 其父类加载器是系统类加载器
+ JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口（自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外），连JDK的核心类库也不例外

```java
//自定义ClassLoader
public class MyClassLoader extends ClassLoader {
    private String byteCodePath;
    
    public MyClassLoader(String byteCodePath) {
        this.byteCodePath = byteCodePath;
    }
    
    public MyClassLoader(ClassLoader parent, String byteCodePath) {
        super(parent);
        this.byteCodePath = byteCodePath;
    }
    
    @Override
    protected Class<?> findClass(String className) throws ClassNotFoundException {
        try {
            String fileName = byteCodePath + className + ".class";
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(fileName));
            ByteArrayOutputStream baos = new ByteArrayOutputStream();

            int len;
            byte[] data = new byte[1024];
            while((len = bis.read(data)) != -1) {
                baos.write(data, 0, len);
            }

            byte[] byteCodes = baos.toByteArray();
            Class clazz = defineClass(null, byteCodes, 0, byteCodes.length);
            return clazz;
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (baos != null)
                    baos.close();
            }  catch (IOException e) {
            	e.printStackTrace();
        	}
            try {
                if (bis != null)
                    bis.close();
            }  catch (IOException e) {
            	e.printStackTrace();
        	}
        }
        return null;
    }
}
```

```java
public class MyClassLoaderTest {
    public static void main(String[] args) {
        MyClassLoader loader = new MyClassLoader("d:/");
        
        Class clazz = loader.loadClass("Demo1");
        System.out.println("加载此类的类加载器为：" + clazz.getClassLoader().getClass().getName());
    }
}
```

#### 8. java9新特性

为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺序运行，仍然发生了一些值得被注意的变动。

1. 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取

   JDK9时基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了

2. 平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader

   如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本JDK中崩溃

3. 在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载相关的问题时会非常有用

4. 启动类加载器现在是在jvm内部和Java类库中共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例

5. 类加载的委派关系也发生了变动

   当平台及应用程序加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载

![](/img/JVM_72.png)

### 下篇-性能监控与调优

### 1. 概述

#### 1. 性能优化的步骤

**(发现问题)：性能监控**

一种以非强行或者入侵的方式收集或查看应用运营性能数据的活动

监控通常是指一种在生产、质量评估或者开发环境下实施的带有预防或主动性的活动

当应用相关干系人提出性能问题却没有提供足够多线索时，首先我们需要进行性能监控随后是性能分析

+ GC频繁
+ CPU load过高
+ OOM
+ 内存泄漏
+ 死锁
+ 程序响应时间较长

**(排查问题)：性能分析**

一种以侵入方式收集运行性能数据的活动，他会影响应用的吞吐量或响应性

性能分析是针对性能问题的答复结果，关注的范围通常比性能监控更加集中

性能分析很少在生产环境下进行，通常是在质量评估、系统测试或者开发环境下进行，是性能监控之后的步骤

+ 打印GC日志，通过GCviewer或者http://gceasy.io来分析日志信息
+ 灵活运用命令行工具，jstack、jmap、jinfo等
+ dump出堆文件，使用内存分析工具分析文件
+ 使用阿里Arthas或jconsole、JVisualVM来实时查看JVM状态
+ jstack查看堆栈信息

**(解决问题)：性能调优**

一种为改善应用响应性或吞吐量而更改参数、源代码、属性配置的活动，性能调优是在性能监控、性能分析之后的活动

+ 适当增加内存，根据业务背景选择垃圾回收器
+ 优化代码，控制内存使用
+ 增加机器，分散节点压力
+ 合理设置线程池线程数量
+ 使用中间件提高程序效率，比如缓存、消息队列等

#### 2. 性能评价/测试指标

**停顿时间（或响应时间）**

提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间

常用操作的响应时间列表

| 操作                              | 响应时间 |
| --------------------------------- | -------- |
| 打开一个站点                      | 几秒     |
| 数据库查询一条记录（有索引）      | 十几毫秒 |
| 机械磁盘一次寻址定位              | 4毫秒    |
| 从机械磁盘顺序读取1M数据          | 2毫秒    |
| 从SSD磁盘顺序读取1M数据           | 0.3毫秒  |
| 从远程分布式换成Redis读取一个数据 | 0.5毫秒  |
| 从内存读取1M数据                  | 十几毫秒 |
| Java程序本地方法调用              | 几微秒   |
| 网络传输2Kb数据                   | 1微秒    |

在垃圾回收环节中：

暂停时间：执行垃圾收集时，程序的工作线程被暂停时间

-XX:MaxGCPauseMillis

**吞吐量**

对单位时间内完成的工作量（请求）的量度

在GC中：运行用户代码的时间占总运行时间的比例（总运行时间：程序的运行时间+内存回收时间）

吞吐量为1-1/(1+n)，-XX:GCTimeRatio=n

**并发数**

同一时刻，对服务器有实际交互的请求数

**内存占用**

Java堆区所占内存的大小

### 2. JVM监控及诊断工具-命令行篇

#### 1. jps：查看正在运行的Java进程

jps(Java Process Status)

显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程

说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的

**jps [options] [hostid]**

options参数

+ -q：仅仅显示LVMID（local virtual machine id），即本地虚拟机唯一id。不显示主类的名称
+ -l：输出应用程序类的全类名或如果进程执行的是jar包，则输出jar完整路径
+ -m：输出虚拟机进程启动时传递给主类main()的参数
+ -v：列出虚拟机进程启动时的JVM参数。比如：-Xms20m -Xmx50m是启动程序指定的jvm参数

如果某Java进程关闭了默认开启的UserPerfData参数（即使用参数-XX:-UsePerfData），那么jps命令（以及下面介绍的jstat）将无法探知该Java进程

hostid参数

RMI注册表中注册的主机名

如果想要远程监控主机上的Java程序，需要安装jstatd

对于对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到IP地址欺诈攻击

如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是在本地使用jstat和jps工具

#### 2. jstat：查看JVM统计信息

jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据

在没有GUI图像界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题

**jstat -< option> [-t] [-h< lines>] < vmid> [< interval> [< count>]]**

查看命令相关参数：jstat -h 或 jstat -help

**option参数**

+ 类装载相关的
  + -class：显示ClassLoader的相关消息：类的装载、卸载数量、总空间、类装载所消耗的时间等
+ 垃圾回收相关的
  + -gc：显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息
  + -gccapacity：显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用的最大、最小空间
  + -gcutil：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比
  + -gccause：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的gc产生的原因
  + -gcnew：显示新生代GC状况
  + -gcnewcapacity：显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间
  + -gcold：显示老年代GC状况
  + -gcoldcapacity：显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间
  + -gcpermcapacity：显示永久代使用的最大、最小空间
+ JIT相关的
  + -compiler：显示JIT编译器编译过的方法、耗时等信息
  + -printcompilation：输出已经被JIT编译的方法

**interval参数**

用于指定输出统计数据的周期，单位为毫秒。即：查询间隔

**count参数**

用于指定查询的总次数

**-t参数**

可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒

**-h参数**

可以在周期性数据输出时，输出多少行数据后输出一个表头信息

#### 3. jinfo：实时查看和修改JVM配置参数

jinfo（Configuration Info For Java）

查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数

在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值

**jinfo [options] pid**

**options参数**

| 选项             | 选项说明                                                     |
| ---------------- | ------------------------------------------------------------ |
| no option        | 输出全部的参数和系统属性                                     |
| -flag name       | 输出对应名称的参数                                           |
| -flag [+-]name   | 开启或者关闭对应名称的参数，只有被标记为manageable的参数才可以被动态修改 |
| -flag name=value | 设定对应名称的参数                                           |
| -flags           | 输出全部的参数                                               |
| -sysprops        | 输出系统属性                                                 |

查看被标记为manageable的参数：java -XX:+PrintFlagsFinal -version | grep manageable

java -XX:+PrintFlagsInitial：查看所有JVM参数启动的初始值

java -XX:+PrintFlagsFinal：查看所有JVM参数的最终值

java -XX:+PrintCommandLineFlags：查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值

#### 4. jmap：导出内存映像文件&内存使用情况

jmap（JVM Memory Map）：作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等

**jmap [option] < pid>**

**jmap [option] < executable < core>**

**jmap [option] [server_id@]< remote server ip or hostname>**

**option参数**

+ -dump：生成Java堆转储快照dump文件，-dump:live只保存堆中存活对象
+ -heap：输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等
+ -histo：输出堆中对象的统计信息，包括类、实例数量和合计容量，-histo:live只统计堆中的存活对象
+ -permstat：以ClassLoader为统计口径输出永久代的内存状态信息，仅Linux、Solaris平台有效
+ -finalizerinfo：显示在F-Queue中等待Finallizer线程执行finalize方法的对象，仅Linux、Solaris平台有效
+ -F：当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件，仅Linux、Solaris平台有效
+ -h | -help：jmap工具使用的帮助命令
+ -J < flag>：传递参数给jmap启动的jvm

**使用1：导出内存映像文件**

Heap Dump又叫做堆转储文件，指一个Java进程在某个时间点的内存快照。Heap Dump在触发内存快照的时候会保存此刻的信息如下：

+ All Objects

  Class,fields,primitive values and references

+ All Classes

  ClassLoader,name,super class,static fields

+ Garbage Collection Roots

  Objects defined to be reachable by the JVM

+ Thread Stacks and Local Variables

  The call-stacks of threads at the moment of the snapshot,and per-frame infomation about local objects

说明：

1. 通常在写Heap Dump文件前会触发一次Full GC,所以heap dump文件里保存的都是FullGC后留下的对象信息
2. 由于生成dump文件比较耗时，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成

**手动的方式**

+ jmap -dump:format=b,file=< filename.hprof> < pid>
+ jmap -dump:live,format=b,file=< filename.hprof> < pid>

**自动的方式**

当程序发生OOM退出系统时，一些瞬时信息都随着程序的终止而消失，而出现OOM问题往往比较困难或者耗时。此时若能在OOM时，自动导出dump文件就显得非常迫切

+ -XX:+HeapDumpOnOutOfMemoryError：在程序发生OOM时，导出应用程序的当前堆快照。
+ -XX:HeapDumpPath=< filename.hprof>：可以指定堆快照的保存位置

**使用2：显示堆内存相关信息**

+ jmap -heap pid
+ jmap -histo pid

**使用3：其它作用**

+ jmap -permstat pid：查看系统的ClassLoader信息
+ jmap -finalizerinfo：查看堆积在finalizer队列中的对象

小结：

由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。

举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象

另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可

#### 5. jhat：JDK自带堆分析工具

jhat（JVM Heap Analysis Tool）

Sun JDK提供的jhat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）

使用了jhat命令，就启动了一个http服务，端口是7000，即http://localhost:7000/，就可以在浏览器里分析

**jhat命令在JDK9、JDK10中已经被删除，官方建议用VisualVM代替**

**jhat [option] [dumpfile]**

**option参数**

+ -stack false|true：关闭|打开对象分配调用栈跟踪
+ -refs false|true：关闭|打开对象引用跟踪
+ -port port-number：设置jhat HTTP Server的端口号，默认7000
+ -exclude exclude-file：执行对象查询时需要排除的数据成员
+ -baseline exclude-file：指定一个基准堆转储
+ -debug int：设置debug级别
+ -version：启动后显示版本信息就退出
+ -J< flag>：传入启动参数，比如-J -Xmx512m

#### 6. jstack：打印JVM中线程快照

jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合

生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况

在thread dump中，要留意下面几种状态

+ 死锁，Deadlock（重点关注）
+ 等待资源，Waiting on condition（重点关注）
+ 等待获取监视器，Waiting on monitor entry（重点关注）
+ 阻塞，Blocked（重点关注）
+ 执行中，Runnable
+ 暂停，Suspended

**jstack option pid**

**option参数**

+ -F：当正常输出的请求不被响应时，强制输出线程堆栈
+ -l：除堆栈外，显示关于锁的附加信息
+ -m：如果调用到本地方法的话，可以显示C/C++的堆栈
+ -h：帮助操作

#### 7. jcmd：多功能命令行

在JDK1.7以后，新增了一个命令行工具jcmd

他是一个多功能的工具，可以用来实现前面处理jstat之外所有命令的功能。比如：用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等

jcmd拥有jmap的大部分功能，并且在Oracle官网上也推荐使用jcmd命令代替jmap命令

+ jcmd -l：列出所有的JVM进程
+ jcmd pid help：针对指定的进程，列出支持的所有命令
+ jcmd pid 具体命令：显示指定进程的指令命令的数据

#### 8. jstatd：远程主机信息收集

之前的指令只涉及到监控本机的Java应用程序，而这些工具中，一些监控工具也支持对远程计算机的监控（如jps、jstat）。为了启用远程监控，则需要配合使用jstatd工具。

命令jstatd是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd服务器将本机的Java应用程序信息传递到远程计算机

### 3. JVM监控及诊断工具-GUI篇

#### 1. 概述

图形化综合诊断工具

+ JDK自带的工具
  + jconsole：JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息永久区（或元空间）使用情况、类加载情况等
  + Visual VM：提供一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息
  + JMC：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据
+ 第三方工具
  + MAT：Memory Analyzer Tool是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗
  + JProfiler：商业软件，需要付费。功能强大
  + Arthas：Alibaba开源的Java诊断工具。深受开发者喜爱
  + Btrace：Java运行时追踪工具，可以在不停机的情况下，跟踪指定的方法调用、构造函数调用和系统内存等信息

#### 2. jConsole

+ 从Java5开始，在JDK中自带的Java监控和管理控制台
+ 用于对JVM中内存、线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监控工具

**三种连接方式**

+ Local：使用JConsole连接一个正在本地系统运行的JVM，并且执行程序的和运行JConsole的需要是同一个用户。JConsole使用文件系统的授权通过RMI连接器连接到平台的MBean服务器上。这种从本地连接的监控能力只有Sun的JDK具有
+ Remote：使用下面的URL通过RMI连接器连接到一个JMX代理，service:jmx:rmi:///jndi/rmi://hostName:portNum/jmxrmi。jConsole为建立连接，需要在环境变量中设置mx.remote.credentials来指定用户名和密码，从而进行授权
+ Advanced：使用一个特殊的URL

#### 3. Visual VM

+ Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具
+ 它集成了多个JDK命令行工具，使用Visual VM可用于显示虚拟机进程及进程的配置和环境信息（jps,jinfo），监视应用程序的CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替JConsole
+ 在JDK6 Update 7以后，Visual VM便作为JDK的一部分发布（Visual VM在JDK/bin目录下）
+ 此外，Visual VM也可以作为独立的软件安装

**插件的安装**

+ Visual VM的一大特点是支持插件扩展，并且插件安装非常方便。我们既可以通过离线下载插件文件*.nbm，然后在Plugin对话框的已下载页面下，添加已下载的插件。也可以在可用插件页面下，在线安装插件。（建议安装：VisualGC）

  插件地址：https://visualvm.github.io/pluginscenters.html

+ IDEA安装VisualVM Launcher插件

  Preferences --> Plugins --> 搜索VisualVM Launcher，安装重启即可

**远程连接**

1. 确定远程服务器的ip地址
2. 添加JMX（通过JMX技术具体监控远程服务器的哪个Java进程）
3. 修改bin/catalina.sh文件，连接远程的tomcat
4. 在../conf中添加jmxremote.access和jmxremote.password文件
5. 将服务器地址改为公网ip地址
6. 设置阿里云安全策略和防火墙策略
7. 启动tomcat，查看tomcat启动日志和端口监听
8. JMX中输入端口号、用户名、密码登录

**主要功能**

1. 生成/读取堆内存快照
2. 查看JVM参数和系统属性
3. 查看运行中的虚拟机进程
4. 生成/读取线程快照
5. 程序资源的实时监控
6. 其他功能
   1. JMX代理lianj
   2. 远程环境监控
   3. CPU分析和内存分析

#### 4. eclipse MAT

MAT（Memory Analyzer Tool）工具是一款功能强大的Java堆内存分析器。可用于查找内存泄漏以及查看内存消耗情况

MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便

**dump文件内容**

MAT可以分析heap dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息

一般来说，这些内存信息包含：

+ 所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值
+ 所有的类信息，包括classloader、类名称、父类、静态变量等
+ GCRoot到所有的这些对象的引用路径
+ 线程信息，包括线程的调用栈及此线程的局部变量（TLS）

说明：

1. MAT不是一个万能的工具，它并不能处理所有类型的堆转储文件。但是比较主流的厂家和格式，例如Sun，HP，SAP所采用的hprof二进制堆转储文件，以及IBM的phd堆转储文件等都能被很好的解析
2. 最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现

**获取dump文件**

1. 通过jmap工具生成，可以生成任意一个Java进程的dump文件

2. 通过配置JVM参数生成

   + -XX:+HeapDumpOnOutOfMemoryError或-XX:+HeapDumpBeforeFullGC

   + -XX:HeapDumpPath所代表的含义就是当程序出现OutOfMemory时，将会在相应的目录下生成一份dump文件，如果不指定-XX:HeapDumpPath则在当前目录下生成dump文件

     生产环境中大都是离线分析，因此使用jmap+MAT工具是最常见的组合

3. 使用VisualVM可以导出dump文件

4. 使用MAT既可以打开一个已有的堆快照，也可以通过MAT直接从活动的Java程序中导出堆快照

**分析dump文件**

+ histogram：展示了各个类的实例数目以及这些实例实例的shallow heap和retained heap总和

+ thread overview：查看系统中的Java线程，查看局部变量的信息

+ 获得对象相互引用的关系：with outgoing references，with incoming references

+ 深堆与浅堆

  **浅堆（shallow heap）**是指一个对象所消耗的内存。在32位系统中，一个对象引用会占4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会向8个字节对齐

  以String为例：2个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节（jdk7中）

  这24字节为String对象的浅堆大小。它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节

  **保留集（Retained Set）**对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象的集合（包括对象A本身），即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。通俗的说，就是仅被对象A所持有的对象的集合

  **深堆（Retained Heap）**是指对象保留集中所有的对象的浅堆大小之和

  注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。

  **对象实际大小**为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关

  对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内

+ 支配树

  支配树的概念源自图论，MAT提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：

  + 对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆
  + 如果对象A支配对象B，那么对象A的直接支配者也支配对象B
  + 支配树的边与对象引用图的边不直接对应

**补充1：再谈内存泄漏**

严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。

但实际情况很多时候一些不太好的实践（或疏忽）会导致对象生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的内存泄漏

内存泄漏的8中情况：

1. 静态集合类

   如HashMap、LinkedList等，如果这些容器为静态的，那么他们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏，简单而言，长生命周期的对象拥有短生命周期对象的引用，尽管短生命周期的对象不再被使用，但是因为长生命周期对象持有它的引用而导致不能被回收

2. 单例模式

   he静态集合导致内存泄漏的原因类似，因为单例的静态特性，它的生命周期和JVM的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么整个外部对象也不会被回收，那么就会造成内存泄漏

3. 内部类持有外部类

   如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使哪个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏

4. 各种连接，如数据库连接、网络连接和IO连接等

   在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象

   否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏

5. 变量不合理的作用域

   一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏，另一方面，如果没有及时地把对象设置成null，很有可能导致内存泄漏的发生

6. 改变哈希值

   当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。

   否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数区HashSet集合中检索对象，也将找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏

7. 缓存泄漏

   内存泄漏的另一个常见来源是缓存，一旦你把对象引用放到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存中，测试环境只有几百条数据，但是生产环境又几百万的数据

   对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值

8. 监听器和回调

   如果客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚

   需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存为WeakHashMap中的键

**补充2：支持使用OQL语言查询对象信息**

#### 5. JProfiler

特点：

+ 方便使用、界面操作友好（简单且强大）
+ 对被分析的应用影响小（提供模板）
+ CPU、Thread、Memory分析功能尤其强大
+ 支持对jdbc，nosql，jsp，servelet，socket等进行分析
+ 支持多种模式（离线，在线）的分析
+ 支持监控本地、远程的JVM
+ 跨平台，拥有多种操作系统的安装版本

主要功能：

1. 方法调用：对方法调用的分析可以帮助你了解应用程序正在做什么，并找到提高其性能的方法
2. 内存分配：通过分析堆上对象、引用链和垃圾收集能帮助修复内存泄漏问题，优化内存使用
3. 线程和锁：JProfiler提供多种针对线程和锁的分析试图帮助发现多线程问题
4. 高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析

#### 6. Arthas