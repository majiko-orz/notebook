#### 七大设计原则

+ 单一职责原则

  对类来说，即一个类应该只负责一项职责。如类A负责两个不同的职责：职责一，职责二，当职责一需求变更而改变A时，可能造成职责二执行错误，所以需要将类A的粒度分解为A1,A2

  + 降低类的复杂度，一个类只负责一项职责
  + 提高类的可读性，可维护性
  + 降低变更引起的风险
  + 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则

+ 接口隔离原则

  客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

  ![](/img/设计模式_1.png)

  ![](/img/设计模式_2.png)

+ 依赖倒置原则

  + 高层模块不应该依赖底层模块，二者都应该依赖其抽象

  + 抽象不应该依赖细节，细节应该依赖抽象
  + 依赖倒转（倒置）的中心思想是面向接口编程
  + 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类
  + 使用接口或抽象类的目的是定制好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

  依赖关系传递的三种方式：

  1. 接口传递
  2. 构造方法传递
  3. setter方式传递

  注意事项：

  1. 底层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
  2. 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
  3. 继承时遵循里氏替换原则

+ 里氏替换原则

  1. 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象
  2. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
  3. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题，通用的做法是：原来的父类和子类都继承一个更通俗的类，原有的继承关系采用聚合，组合，依赖等关系代替
  4. 子类可以扩展父类的功能，但不能改变父类原有的功能

+ 开闭原则ocp

  1. 开闭原则是编程中最基础、最重要的设计原则
  2. 一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节
  3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
  4. 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则

+ 迪米特原则

  1. 一个对象应该对其他对象保持最少的了解
  2. 类与类关系越密切，耦合度越大
  3. 迪米特法则又叫最少知道原则，即一个类对自己依赖的的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄漏任何信息
  4. 迪米特法则还有个更简单的定义：只与直接的朋友通信
  5. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部

  注意事项：

  1. 迪米特法则的核心是降低类之间的耦合
  2. 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖

+ 合成复用原则

  尽量使用合成/聚合的方式，而不是使用继承

设计原则的核心思想：

1. 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起
2. 针对接口编程，而不是针对实现编程
3. 为了交互对象之间的松耦合设计而努力

#### UML类图

类之间关系：依赖、泛化（继承）、实现、关联、聚合和组合

1. 依赖：如果类中用到了对方，那么他们之间就存在依赖
2. 泛化：实际上就是继承关系，他是依赖关系的特例
3. 实现：实际上就是A类实现B类，他是依赖关系的特例
4. 关联：实际上就是类与类之间的联系，他是依赖关系的特例
   + 关联具有导航性：即双向关系或单向关系
   + 关系具有多重性：如一对一，一对多
5. 聚合：表示的是整体和部分的关系，整体和部分可以分开。聚合关系是关联关系的特例，所以它具有关联的导航性与多重性
6. 组合：表示的是整体和部分的关系，整体和部分不可以分开

#### 模式类目

+ 创建型：创建型模式牵涉到对象实例化，这类模式都提供一种将客户从需要实例化的对象中解耦的方式

  单例、抽象工厂、工厂方法、原型、生成器（建造者）

+ 行为型：行为型模式都涉及类和对象如何交互，已经分配责任

  模板方法、解释器、命令、责任链、策略、中介者、访问者、迭代器、备忘录、观察者、状态

+ 结构型：结构型模式让你组合类或对象得到更大的结构

  装饰者、蝇量（享元）、组合、适配器、代理、外观、桥接

第二种分类方式：

+ 类模式：类模式描述类之间的关系是如何通过继承定义。类模式中的关系是在编译时建立的

  模板方法、工厂方法、适配器、解释器

+ 对象模式：对象模式描述对象之间的关系，而且对象模式主要通过组合定义。对象模式中的关系通常在运行时创建，更加动态和有弹性

  组合、装饰者、代理、策略、桥接、蝇量、抽象工厂、外观、责任链、中介者、原型、生成器、单例、状态、访问者、命令、迭代器、备忘录、观察者

#### 单例模式(Singleton)

单例模式就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类提供一个取得其对象实例的方法

单例设计模式有八种方式：

1. **饿汉式（静态常量）**

   + 构造器私有化（防止new）
   + 类的内部创建对象
   + 向外暴露一个静态的公共方法

   ```java
   class Singleton {
       
       //1.构造器私有化，外部不能new
       private Singleton() {
           
       }
       
       //2.本类内部创建对象实例
       private final static Singleton instance = new Singleton();
       
       //3.提供一个公有的静态方法，返回实例对象
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

   优缺点说明：

   1. 优点：写法简单，就是在类装载的时候就完成实例化，避免了线程同步问题
   2. 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终从未使用过这个实例，就会造成内存的浪费
   3. 这种方式基于classloader机制避免了多线程同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多，因此不能确定有其他方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果
   4. 结论：这种单例模式可用，可能造成内存浪费

2. **饿汉式（静态代码块）**

   ```java
   class Singleton {
       
       //1.构造器私有化，外部不能new
       private Singleton() {
           
       }
       
       //2.本类内部创建对象实例
       private static Singleton instance;
       
       //在静态代码块中，创建单例对象
       static {
           instance = new Singleton();
       }
       
       //3.提供一个公有的静态方法，返回实例对象
       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

   优缺点说明：

   1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的
   2. 结论：这种单例模式可用，但是可能造成内存浪费

3. 懒汉式（线程不安全）

   ```java
   class Singleton {
       
       private static Singleton instance;
       
       private Singleton() {}
       
       //提供一个公有的静态方法，当使用到该方法时，才去创建instance
       public static Singleton getInstance() {
           if(instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   ```

   优缺点说明：

   1. 起到了lazy loading的效果，但是只能在单线程下使用
   2. 如果在多线程下，一个线程进入了if(singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例，所以在多线程环境下不可使用这种方式
   3. 结论：在实际开发中，不要使用这种方式

4. 懒汉式（线程安全，同步方法）

   ```java
   class Singleton {
       
       private static Singleton instance;
       
       private Singleton() {}
       
       //提供一个公有的静态方法，加入同步处理的代码，解决线程安全问题
       public static synchronized Singleton getInstance() {
           if(instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   ```

   优缺点说明：

   1. 解决了线程安全问题
   2. 效率太低了，每个线程在想获得类的实例的时候，执行getInstance()方法都要进行同步，而其实这个方法只执行一次实例化代码就够了，后面想获得该类实例，直接return就行了，方法进行同步效率太低
   3. 结论：在实际开发中，不推荐使用这种方式

5. 懒汉式（线程不安全，同步代码块）

   ```java
   class Singleton {
       
       private static Singleton instance;
       
       private Singleton() {}
       
       public static Singleton getInstance() {
           if(instance == null) {
               synchronized (Singleton.class) {
                   instance = new Singleton();
               }
           }
           return instance;
       }
   }
   ```

   优缺点说明：

   1. 不能起到线程同步的作用
   2. 结论：在实际开发中，不能使用这种方式

6. **双重检查**

   ```java
   class Singleton {
       
       private static volatile Singleton instance;
       
       private Singleton() {}
       
       //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题
       //懒汉式
       public static Singleton getInstance() {
           if(instance == null) {
               synchronized(Singleton.class) {
                   if(instance == null) {
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
   }
   ```

   优缺点说明：

   1. Double-Check概念时多线程开发中常使用到的，进行了两次if(instance == null)检查，这样就可以保证线程安全了
   2. 实例化代码只用一次，后面再次访问时，判断if(instance == null)直接return实例化对象，也避免反复进行方法同步
   3. 线程安全，延迟加载，效率较高
   4. 结论：在实际开发中，推荐使用

7. **静态内部类**

   ```java
   class Singleton {
       
       private static volatile Singleton instance;
       
       private Singleton() {}
       
       //写一个静态内部类，该类中有一个静态属性Singleton
       private static class SingletonInstance {
           private static final Singleton INSTANCE = new Singleton(); 
       }
       
       //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
       public static Singleton getInstance() { 
           return SingletonInstance.INSTANCE;
       }
   }
   ```

   优缺点说明：

   1. 这种方式采用类装载的机制来保证初始化实例时只有一个线程
   2. 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化
   3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的
   4. 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
   5. 结论：推荐使用

8. **枚举**

   ```java
   enum Singleton {
       INSTANCE;
       public void method() {
           
       }
   }
   ```

   优缺点说明：

   1. 借助JDK1.5中添加的枚举类来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象
   2. 结论：推荐使用

#### 简单工厂模式

1. 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例，简单工厂模式是工厂模式中最简单实用的模式
2. 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为
3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式

![](/img/设计模式_4.png)

#### 工厂方法模式(FactoryMethod)

定义一个创建对象的抽象方法，由子类决定要实现的类，工厂方法模式将对象的实例化推迟到子类

![](/img/设计模式_3.png)

#### 抽象工厂模式(AbstractFactory)

1. 定义一个接口用于创建相关或有依赖关系的对象簇，而无需指明具体的类
2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合
3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）
4. 将工厂抽象为两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类，这样将单个的简单工厂变为工厂簇，更利于代码的维护和扩展

![](/img/设计模式_5.png)

小结：

1. 工厂模式的意义：将实例化对象的代码提取出来，放到一个类中同一管理和维护，达到和主项目的依赖关系的解耦，从而提高项目的扩展和维护性
2. 三种工厂模式
3. 设计模式的依赖抽象原则
4. 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂方法中，并返回
5. 不要让类继承具体类，而是继承抽象类或者是实现接口
6. 不要覆盖类中已经实现的方法

https://www.cnblogs.com/blessing2022/p/16622131.html

#### 原型模式(Protorype)

1. 原型模式（prototype）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制对象，无需知道如何创建的细节
3. 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发的创建的对象通过请求原型对象拷贝他们自己来实施创建，即 对象.clone()

![](/img/设计模式_6.png)

+ Prototype：原型类，声明一个克隆自己的接口
+ ConcretePrototype：具体的原型类，实现一个克隆自己的操作
+ Client：让一个原型对象克隆自己，从而创建一个新的对象

**浅拷贝**

1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新对象
2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是该成员变量的引用值（内存地址）复制一份给新对象。因为实际上两个对象的该成员变量都指向同一个实例，在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
3. 浅拷贝是使用默认的clone()方法来实现

**深拷贝**

1. 复制对象的所有基本数据类型的成员变量值
2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝
3. 深拷贝实现方式1：重写clone()方法来实现深拷贝
4. 深拷贝实现方式2：通过对象序列化实现深拷贝

```java
public class DeepProtoType implements Serializable,Cloneable{
    public String name;
    public DeepCloneableTarget deepCloneableTarget;
    public DeepPrototype() {
        super();
    }
    
    //深拷贝-方式1使用clone()方法
    @Override
    protected Object clone() throws CloneNotSupportedException {
        
        Object deep = null;
        
        deep = super.clone();
        //对引用类型的数据进行单独处理
        DeepProtoType deepProtoType = (DeepProtoType)deep;
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget)deepCloneableTarget.clone(); 
        return deepProtoType;
    }
    
    //深拷贝-方式2通过对象的序列化实现（推荐）
    public Object deepClone() {
        
        //创建流对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayIntputStream bis = null;
        ObjectIntputStream ois = null;
        
        try {
            //序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);
            
            //反序列化
            bis = new ByteArrayIntputStream(bos.toByteArray());
            ois = new ObjectIntputStream(bis);
            DeepProtoType copyObjec = (DeepProtoType)ois.readObject();
            
            return copyObject;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

原型模式的注意事项和细节：

1. 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
2. 不用重新初始化对象，而是动态地获得对象运行时的状态
3. 如果原始对象发生变化（增加或减少属性），其他克隆对象也会发生相应的变化，无须修改代码
4. 在实现深克隆时可能需要比较复杂的代码
5. 缺点：需要为每一个类配置一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则

#### 建造者模式(Builder)

1. 建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的构建过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象
2. 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节

**建造者模式的四个角色**

+ Product(产品角色)：一个具体的产品对象
+ Bulider(抽象建造者)：创建一个Product对象的各个部件指定的接口
+ ConcreteBulider(具体构建者)：实现接口，构建和装配各个部件
+ Director(指挥者)：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程

![](/img/设计模式_7.png)

建造者模式的注意事项和细节：

1. 客户端（使用程序不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象）

2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便的替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象

3. 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程

4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合开闭原则

5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制

6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式

7. 抽象工厂模式vs建造者模式

   抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心说明产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，他的主要目的是通过组装零配件而产生一个新产品

#### 适配器模式(Adapter)

1. 适配器模式将一个类的接口转换成客户期望的另一个接口，主要目的是兼容性，让原本接口不兼容的类可以合作，其别名为包装器（Wrapper）
2. 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式

**类适配器模式**

Adapter类通过继承src类，实现dst类接口，完成src->dst的适配

![](/img/设计模式_8.png)

类适配器模式注意事项和细节

1. Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性
2. src类的方法在Adapter中都会暴露出来，也增加了使用的成本
3. 由于其继承了src类，所以提尕可以根据需求重写src类的方法，使得Adaper的灵活性增强了

**对象适配器模式**

1. 基本思路和类适配器相同，只是将Adapter类做修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src->dst的适配
2. 根据合成复用原则，在系统中尽量使用关联关系来替代继承关系
3. 对象适配器模式是适配器模式中常用的一种

![](/img/设计模式_9.png)

**接口适配器模式**

1. 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求
2. 适用于一个接口不想使用其所有方法的情况

#### 桥接模式(Bridge)

1. 桥接模式(Bridge模式)是将抽象部分与他的实现部分分离，使他们都可以独立的变化
2. Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责，它的主要特点是把抽象和行为实现分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展

![](/img/设计模式_10.png)

说明：

1. Client类：桥接模式的调用者
2. 抽象类（Abstraction）：维护了Implementor/即它的实现类ConcreteImplementorA..，二者是聚合关系，Abstraction充当桥接类
3. RefinedAbstraction：是Abstraction抽象类的子类
4. Implementor：行为实现类的接口
5. ConcreteImplementorA/B：行为的具体实现类

注意事项和细节：

1. 实现类抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统
2. 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他的部分由具体业务来完成
3. 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本
4. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
5. 桥接模式要求正确识别出系统中两个独立变化的维度，因此使用范围有一定的局限性，即需要有这样的应用场景

#### 装饰者模式(Decorator)

装饰者模式：动态的将新功能附加到对象上，在对象功能扩展方面，他比继承更有弹性，装饰者模式也体现了开闭原则

![](/img/设计模式_11.png)

#### 组合模式(Composite)

1. 组合模式又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示整体-部分的层次关系
2. 组合模式依据树形结构来组合对象，用来表示部分以及整体层次
3. 组合模式使得用户对单个对象和组合对象的访问具有一致性，即，组合能让客户以一致的方式处理个别对象以及组合对象

![](/img/设计模式_12.png)

1. Component：这是组合中的对象声明接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理Component子部件，Component可以是抽象类或者接口
2. Leaf：在组合中表示叶子节点，叶子节点没有子节点
3. Composite：非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加、删除

解决的问题：

当我们要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑他是节点还是叶子

注意事项和细节：

1. 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题
2. 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何修改
3. 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
4. 需要遍历组织结构，或者处理的对象具有树形结构时，非常适合使用组合模式
5. 要求较高的抽象性，如果节点和叶子有很多差异性的化，比如很多方法和属性都不一样，不适合使用组合模式

#### 外观模式(Facade)

1. 外观模式，也叫过程模式：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
2. 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关系这个子系统的内部细节

![](/img/设计模式_13.png)

注意事项和细节：

1. 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
2. 外观模式对客户端和子系统的耦合关系，让子系统内部的模块更易维护和扩展
3. 通过合理的使用外观模式，可以帮助我们更好的划分访问的层次
4. 当系统需要进行分层设计时，可以考虑使用facade模式
5. 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个facade类，来提供遗留系统的比较清晰简单的接口，让新系统与facade类交互，提高复用性
6. 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以让系统有层次，利于维护为目的

#### 享元模式(FlyWeight)

1. 享元模式也叫蝇量模式，运用共享技术有效地支持大量细粒度的对象
2. 常用于系统底层开发，解决系统的性能问题，像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
3. 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时，不需要总是创建新对象，可以从缓冲池里拿，这样可以降低系统内存，同时提高效率
4. 享元模式经典的应用场景就是池技术，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式

![](/img/设计模式_14.png)

1. FlyWeight是抽象的享元角色，同时定义出对象的外部状态和内部状态的接口或实现
2. ConcreteFlyWeight是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务
3. UnsharedConcreteFlyWeight是不可共享的角色，一般不会出现在享元工厂
4. FlyWeightFactory享元工厂类，用于构建一个池容器，同时提供从池中获取对象的方法

享元模式提出了两个要求：细粒度和共享对象，这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：**内部状态和外部状态**

**内部状态**指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变

**外部状态**指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态

注意事项和细节：

1. 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式了
2. 用唯一标识符判断，如果在内存中有，则返回这个唯一标识符所标识的对象，用HashMap/HashTable存储
3. 享元模式大大减少了对象的创建，降低了程序内存的使用，提高效率
4. 享元模式提高了系统的复杂度，需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方
5. 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制
6. 享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池

#### 代理模式(Proxy)

1. 代理模式为另一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，这样做的好处是，可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能
2. 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
3. 代理模式有不同的形式，主要有三种**静态代理、动态代理（JDK代理、接口代理）和Cglib代理（可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴）**

**静态代理**

静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同的父类

![](/img/设计模式_15.png)

静态代理优缺点

1. 优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展

2. 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类

3. 一旦接口增加方法，目标对象与代理对象都要维护

**动态代理**

1. 代理对象不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
2. 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象
3. 动态代理也叫做JDK代理、接口代理

JDK中生成代理对象的API

1. 代理类所在包：java.lang.reflect.Proxy
2. JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，完整的写法是：static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)

![](/img/设计模式_16.png)

```java
public Object getProxyInstance() {
    
    //1.ClassLoader loader:指定当前目标对象使用的类加载器，获取加载器的方法固定
    //2.Class<?>[] interfaces:目标对象实现的接口类型，使用泛型方法确认类型
    //3.InvocationHandler h:事件处理，执行目标对象的方法时，会触发事情处理器方法，会把当前执行的目标对象方法作为一个参数传入
    return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
        
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) {
            //反射机制调用目标对象的方法
            Object returnVal = method.invoke(target, args);
            return returnVal
        }
    });
}
```

**Cglib代理**

1. 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理
2. Cglib代理也叫做子类代理，他是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理
3. Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口，它广泛的被许多AOP的框架使用，例如SpringAOP，实现方法拦截
4. 在AOP编程中如何选择代理模式：
   1. 目标对象需要实现接口，用JDK代理
   2. 目标对象不需要实现接口，用Cglib代理
5. Cglib包的底层是通过字节码处理框架ASM来转换字节码并生成新的类

Cglib代理模式实现步骤：

1. 需要引入cglib的jar文件
2. 在内存中动态构建子类，注意代理的类不能为final，否则报错java.lang.illegalArgumentException
3. 目标对象的方法如果是final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法

![](/img/设计模式_17.png)

**代理模式的变体**

1. 防火墙代理：内网通过代理穿透防火墙，实现对公网的访问
2. 缓存代理：比如当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok，如果取不到资源再到公网或者数据库取，然后缓存
3. 远程代理：远程对象的本地代表，通过它可以把远程对象当作本地对象来调用，远程代理通过网络和真正的远程对象沟通信息
4. 同步代理：主要使用在多线程中，完成多线程间同步工作

#### 模板方法模式(TemplateMethod)

1. 模板方法模式又叫模板模式，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行
2. 在一个方法中定义一个算法的骨架，而把一些步骤延迟到子类。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

![](/img/设计模式_18.png)

1. AbstractClass抽象类，类中实现了模板方法template，定义了算法的骨架，具体子类需要去实现其他的抽象方法operation2,3,4
2. ConcreteClass实现抽象方法operation2,3,4，以完成算法中特定子类的步骤

**模板方法模式的钩子方法**

1. 在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为钩子
2. 钩子是一个声明在抽象类中的方法，但他只给出空的或缺省的实现，这给了子类在变化点挂钩进算法的能力，如果需要，子类也有权忽略钩子

注意事项和细节：

1. 基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改
2. 实现类最大化代码复用，父类的模板方法和已实现的某些步骤会被子类继承而直接使用
3. 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现
4. 该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大
5. 一般模板方法都加上final关键字，防止子类重写模板方法
6. 模板方法模式使用场景：当要完成某个过程，该过程要执行一系列步骤，这一些列步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理

#### 命令模式(Command)

1. 命令模式：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计
2. 命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦
3. 命令模式把请求封装为对象，以便用不同的请求、队列或者日志请求来参数化其他对象，并支持可撤销的操作
4. 通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令（连接将军和士兵）

![](/img/设计模式_19.png)

1. Invoker：调用者角色
2. Command：命令角色，需要执行的所有命令都在这里，可以是接口或抽象类
3. Receiver：接收者角色，知道如何实施和执行一个请求相关的操作
4. ConcreteCommand：将一个接收者对象与一个动作绑定，调用接收者相应的操作，实现execute

注意事项和细节：

1. 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说，请求发起者和请求执行者之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用
2. 容易设计一个命令队列，只要把对象命令放到队列，就可以多线程的执行命令
3. 容易实现对请求的撤销和重做
4. 命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候要注意
5. 空命令也是一种设计模式，它为我们省去了判空的操作
6. 命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD订单的撤销/恢复、触发-反馈机制

#### 访问者模式(Visitor)

1. 访问者模式，封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作
2. 主要将数据结构与数据操作分离，解决数据结构和操作耦合性的问题
3. 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口
4. 访问者模式的主要应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联，同时需要避免让这些操作污染这些对象的类，可以选用访问者模式解决）

![](/img/设计模式_20.png)

1. Visitor：抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作
2. ConcreteVisitor：是一个具体的访问者，实现每个有Visitor声明的操作，是每个操作实现的部分
3. ObjectStructure：能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素
4. Element：定义一个accept方法，接受一个访问者对象
5. ConcreteElement：为具体元素，实现accept方法

注意事项和细节：

优点

1. 访问者模式符合单一职责原则，让程序具有优秀的扩展性、灵活性非常高
2. 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统

缺点

1. 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难
2. 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素
3. 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的

#### 迭代器模式(Iterator)

1. 如果我们的集合元素是用不同的方式实现的，有数组，还有Java的集合类，或者还有其他的方式，当客户端要遍历这些集合元素时就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑用迭代器模式解决
2. 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构

![](/img/设计模式_21.png)

1. Iterator：迭代器接口，是系统提供，含有hasNext,next,remove
2. ConcreteIterator：具体的迭代器，管理迭代
3. Aggregate：一个统一的聚合接口，将客户端和具体聚合解耦
4. ConcreteAggregate：具体的聚合持有对象集合，并提供一个方法，返回一个迭代器，该迭代器可以正确遍历集合
5. Client：客户端，通过Iterator和Aggregate依赖子类

注意事项和细节：

优点

1. 提供了一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了
2. 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成
3. 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（单一职责原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器
4. 当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式

缺点

每个聚合对象都要有一个迭代器，会生成多个迭代器不好管理类

#### 观察者模式(Observer)

观察者模式定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新

![](/img/设计模式_22.png)

观察者模式的好处：

1. 观察者模式设计后，会以集合的方式来管理用户，包括注册、移除和通知
2. 我们增加观察者就不需要去修改核心类WeatherData的代码，遵守了ocp原则

#### 中介者模式(Mediator)

1. 中介者模式，用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互
2. 比如MVC模式C是M和V的中介者，在前后端交互时起到了中间人的作用

![](/img/设计模式_23.png)

1. Mediator就是抽象中介者，定义了同事对象到中介者对象的接口
2. Colleage是抽象同事类
3. ConcreteMediator具体的中介者对象，实现抽象方法，他需要知道所有具体的同事类，即以一个集合来管理HashMap，并接受某个同事对象的消息，完成相应的任务
4. ConcreteColleage具体的同事类，会有很多，每个同事只知道自己的行为，而不了解其他同事类的行为，但是他们都依赖中介者对象

注意事项和细节：

1. 多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离为星型结构进行解耦
2. 减少类间依赖，降低了耦合符合迪米特原则
3. 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响
4. 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时要特别注意

#### 备忘录模式(Memento)

1. 备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态
2. 备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作

![](/img/设计模式_24.png)

1. Originator：对象（需要保存状态的对象）
2. Memento：备忘录对象，负责保存好记录，即Originator内部状态
3. Caretaker：守护者对象，负责保存多个备忘录对象，使用集合提高效率

注意事项和细节：

1. 给用户提供了一种可以恢复状态的机制，可以使用户能够方便地回到某个历史的状态

2. 实现了信息的封装，使得用户不需要关系状态的保存细节
3. 如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存，这个需要注意
4. 为了节约内存，备忘录模式可以和原型模式配合使用

#### 解释器模式(Interpreter)

1. 在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器可以看作是解释器
2. 解释器模式是指给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）

![](/img/设计模式_25.png)

1. Context：环境角色，含有解释器之外的全局信息
2. AbstractExpression：声明一个抽象的解释操作，这个方法为抽象语法树中所有的节点所共享
3. TerminalExpression：为终结符表达式，实现与文法中的终结符相关的解释操作
4. NonTerminalExpression：为非终结符表达式，为文法中的非终结符实现解释操作

注意事项和细节：

1. 当有一个语言需要解释执行，可将该语言的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性
2. 应用场景：编译器、运算表达式计算、正则表达式
3. 使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低

#### 状态模式(State)

1. 状态模式：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题，状态和行为是一一对应的，状态之间可以相互转换
2. 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类

![](/img/设计模式_26.png)

1. Context类为环境角色，用于维护State实例，这个实例定义当前的状态
2. State是抽象状态角色，定义一个接口封装与Context的一个特定接口相关行为
3. ConreteState具体的状态角色，每个子类实现一个与context的一个状态相关行为

注意事项和细节：

1. 代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中
2. 方便维护。将容易产生问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错
3. 符合开闭原则，容易增删状态
4. 会产生很多类，每个状态都要一个对应类，当状态过多时会产生很多类，加大维护难度
5. 当一个事件或者对象有很多状态，状态之间会相互转换，对不同的状态有不同的行为的时候，可以考虑使用状态模式

#### 策略模式(Strategy)

1. 策略模式定义了一个算法族，分别封装起来，使得他们之间可以互相变换，策略让算法的变化独立于使用他的客户
2. 这个算法体现了几个设计原则：第一、把变化的代码从不变的代码中分离出来;第二、针对接口编程而不是具体类（定义了策略接口）;第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）

![](/img/设计模式_27.png)

注意事项和细节：

1. 策略模式的关键是：分析项目中变化部分与不变部分
2. 策略模式的核心思想是：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承，更有弹性
3. 体现了对修改关闭，对扩展开放原则，客户端增加行为不用修改原有代码，只要添加一种策略即可，避免了使用多重转移语句（if..else if..else）
4. 提供了可以替换继承关系的方法：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变他，使它易于切换、易于理解、易于扩展
5. 需要注意的是：每增加一个策略就要增加一个类，当策略过多时会导致类数目庞大

#### 责任链模式(Chain of Responsibility)

1. 责任链模式为请求创建了一个接收者对象的链，这种模式对请求的发送者和接收者进行解耦
2. 责任链模式通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么他会把相同的请求传给下一个接收者，依次类推

![](/img/设计模式_28.png)

1. Handler：抽象的处理者，定义了一个处理请求的接口，同时含有另外Handler
2. ConcreteHandlerA,B是具体的处理者，处理它负责的请求，可以访问它的后继者，如果可以处理当前请求，则处理，否则就将该请求交给后继者去处理，从而形成一个责任链
3. Request：含有很多属性，表示一个请求

注意事项和细节：

1. 将请求和处理分开，实现解耦，提高系统灵活性
2. 简化了对象，使对象不需要知道链的结构
3. 性能会受影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量，在setNext()方法中判断是否已经超过阈值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能
4. 调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂