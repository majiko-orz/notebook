### 复杂度和简单排序算法

#### 时间复杂度

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

在表达式中只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为0(f(N))

评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数时间

#### 选择排序

时间复杂度O(N^2)，额外空间复杂度O(1)

```java
public void selectSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.lenth; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        int tmp = arr[j];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

#### 冒泡排序

时间复杂度O(N^2)，额外空间复杂度O(0)

```java
public void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int e = arr.length - 1; e > 0; e--){
        for (int i = 0; i < e; i++) {
            if (arr[i] > arr[i + 1]){
                arr[i] = arr[i] ^ arr[i + 1];
                arr[i + 1] = arr[i] ^ arr[i + 1];
                arr[i] = arr[i] ^ arr[i + 1];
            }
        }
    }
}
```

#### 异或运算

0 ^ N = N

N ^ N = 0

a ^ b = b ^ a

(a ^ b) ^ c = a ^ (b ^ c)

交换两个值（a,b内存地址不同，否则为0）：

a = a ^ b;

b = a ^ b;

a = a ^ b;

#### 一个数组，一种数为奇数次，其他为偶数次，求这个数

```java
public void printOddTimesNum1(int[] arr) {
    int eor = 0;
    for (int cur : arr) {
        eor ^= cur;
    }
    System.out.println(eor);
}
```

#### 一个数组，两种数为奇数次，其他为偶数次，求这个数

```java
public void printOddTimesNum2(int[] arr) {
    int eor = 0;
    for (int curNum : arr) {
        eor ^= curNum;
    }
    int rightOne = eor & (~eor + 1);//提取出最右的1
    int onlyOne = 0;
    for (int cur : arr) {
        if ((cur & rightOne) == 0) {
            onlyOne ^= cur
        }
    }
    System.out.println(onlyOne + " " + (eor ^ onlyOne));
}
```

#### 插入排序

时间复杂度O(N^2)，额外空间复杂度O(1)

```java
public void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = 1; i < arr.lenth; i++) {
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            arr[i] = arr[i] ^ arr[j];
            arr[j] = arr[i] ^ arr[j];
            arr[i] = arr[i] ^ arr[j];
        }
    }
}
```

### O(NlogN)的排序

#### 递归行为时间复杂度的估算

**master公式：T(N) = a * T(N / b) + O(N ^ d)**

1. log(b, a) > d -> 复杂度为O(N ^ log(b, a))
2. log(b, a) = d -> 复杂度为O(N ^ d * logN)
3. log(b, a) < d -> 复杂度为O(N ^ d)

#### 归并排序

时间复杂度O(N * logN)，额外空间复杂度O(N)

```java
public void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    process(arr, 0, arr.length - 1);
}

public void process(int[] arr, int L, int R) {
    if (L == R) {
        return;
    }
    int mid = L + ((R - L) >> 1);
    process(arr, L, mid);
    process(arr, mid + 1, R);
    merge(arr, L, mid, R);
}

public void merge(int[] arr, int L, int M, int R) {
    int[] help = new int[R - L + 1];
    int i = 0;
    int p1 = L;
    int p2 = M + 1;
    while (p1 <= M && p2 <= R) {
        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= M) {
        help[i++] = arr[p1++]
    }
    while (p1 <= M) {
        help[i++] = arr[p2++]
    }
    for (i = 0; i < help.length; i++) {
        arr[L + i] = help[i];
    }
}
```

#### 小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和

```java
public int smallSum(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    return process(arr, 0, arr.length - 1);
}

public int process(int[] arr, int l, int r) {
    if (l == r) {
        return 0;
    }
    int mid = l + ((l - r) >> 1);
    return process(arr, l, mid)
         + process(arr, mid, r)
         + merge(arr, l, mid, r);
}

public int merge(int[] arr, int l, int m, int r) {
    int[] help = new int[r - l + 1];
    int i = 0;
    int p1 = l;
    int p2 = m + 1;
    int res = 0;
    while (p1 <= m && p2 <= r) {
        res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= m) {
        help[i++] = arr[p1++]
    }
    while (p2 <= r) {
        help[i++] = arr[p2++]
    }
    for (i = 0; i < help.length; i++) {
        arr[l + i] = help[i];
    }
    return res;
}
```

#### 快速排序

时间复杂度O(N * logN)

```java
public void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    quickSort(arr, 0, arr.length - 1);
}

public void quickSort(int[] arr, int L, int R) {
    if (L < R) {
        swap(arr, L + (int)(Math.random() * (R - L + 1)), R);
    	int[] p = partition(arr, L, R);
    	quickSort(arr, L, p[0] - 1);
    	quickSort(arr, p[1] + 1, R);
    }
}

public int[] partition(int[] arr, int L, int R) {
    int less = L - 1;
    int more = R;
    while (L < more) {
        if (arr[L] < arr[R]) {
            swap(arr, ++less, L++);
        } else if (arr[L] > arr[R]) {
            swap(arr, --more, L);
        } else {
            L++;
        }
    }
    swap(arr, more, R);
    return new int[] { less + 1, more};
}
```

### 桶排序及排序总结

#### 堆排序

时间复杂度O(N * logN)

```java
public void heapSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
//    for (int i = 0; i < arr.length; i++) {
//        heapInsert(arr, i);
//    }
    
    //稍快于上面方法
    for (int i = arr.length - 1; i >= 0; i--) {
        heapify(arr, i, arr.length);
    }
    
    int heapSize = arr.length;
    swap(arr, 0, --heapSize);
    while (heapSize > 0) {
        heapify(arr, 0, heapSize);
        swap(arr, 0, --heapSize);
    }
}

public void heapInsert(int[] arr, int index) {
    while (arr[index] > arr[(index - 1) / 2]) {
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}

public void heapify(int[] arr, int index, int heapSize) {
    int left = index * 2 + 1;
    while (left < heapSize) {
        int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        largest = arr[largest] > arr[index] ? largest : index;
        if (largest == index) {
            break;
        }
        swap(arr, largest, index);
        left = index * 2 + 1;
    }
}
```

#### 希尔排序

#### 基数排序